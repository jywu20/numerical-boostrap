\documentclass[oneside]{fduthesis}

\fdusetup{
  style = {
    font = lm,
    % 西文字体（包括数学字体）
    % 允许选项：
    %   font = garamond|libertinus|lm|palatino|times
    %
    % 注意：
    %   1. LaTeX 默认风格是 lm
    %   2. Satoshi 的讲义风格是 palatino
    %
    cjk-font = windows,
    % 中文字体
    % 允许选项：
    %   cjk-font = adobe|fandol|founder|mac|sinotype|sourcehan|windows
    %
    % 注意：
    %   1. 中文字体设置高度依赖于系统。各系统建议方案：
    %        windows：cjk-font = windows
    %        mac：    cjk-font = mac
    %        linux：  cjk-font = fandol（默认值）
    %   2. 除 fandol 和 sourcehan 外，其余字体均为商用字体，请注意版权问题
    %   3. 但 fandol 字体缺字比较严重，而 sourcehan 没有配备楷体和仿宋体
    %   4. 某些字体会有 Font "xxx" does not contain requested Script "CJK" 的警告，可以忽略
    %
    font-size    = -4,
    bib-backend  = bibtex,
    bib-resource = {main.bib},
  },
  info = {
      title            = {数值Bootstrap及其在凝聚态物理中的应用},
      % title            = {如果标题很长,可以用英文逗号分成两行},
      author           = {吴晋渊},
      department       = {物理学系},
      major            = {物理学},
      supervisor       = {戚扬},
      supervisor-title = {研究员},
      affiliation      = {物理学系},
      student-id       = {18307110155},
      keywords         = {Bootstrap, Hubbard模型, 非简谐振子},
      keywords*        = {Bootstrap, Hubbard model, nonlinear oscillator},
      % 中英文关键字均使用英文逗号分隔
  }
}

\unimathsetup{math-style=TeX}

% 需要的宏包可以自行调用
\usepackage{booktabs}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{siunitx}
\usepackage{physics}
\usepackage{tikz}
\usepackage{cancel}
\usepackage{color}
\usepackage{array}
\usepackage{verbatim}
\usepackage{multirow}
\usepackage{tabularx}
\usepackage{extarrows}
\usepackage{listings}
\usepackage{subcaption}
\usepackage[linkcolor=black,menucolor=black]{hyperref}
\usepackage{prettyref}

\usetikzlibrary{fadings}
\usetikzlibrary{patterns}
\usetikzlibrary{shadows.blur}
\usetikzlibrary{shapes}

\newrefformat{chap}{第\ref{#1}章}
\newrefformat{sec}{第\ref{#1}节}
\newrefformat{note}{注\ref{#1}}
\newrefformat{fig}{图\ref{#1}}
\newrefformat{alg}{算法\ref{#1}}
\newrefformat{tbl}{表\ref{#1}}

\newcommand{\hilbertH}{\symcal{H}}
\newcommand{\ee}{\symrm{e}}
\newcommand{\ii}{\symrm{i}}

\newcommand{\concept}[1]{\textbf{#1}}

% Disable unsupported commands in bookmark titles 
\pdfstringdefDisableCommands{%
  \def\\{}%
  \def\texttt#1{<#1>}%
  \def\mathbb#1{#1}%
}
\pdfstringdefDisableCommands{\def\eqref#1{(\ref{#1})}}

\makeatletter
\pdfstringdefDisableCommands{\let\HyPsd@CatcodeWarning\@gobble}
\makeatother

% 图片路径
% \graphicspath{{images/}}

% 目录深度，只保留到 \section
\setcounter{tocdepth}{2}

\begin{document}

\renewcommand{\Re}{\mathrm{Re}}
\renewcommand{\Im}{\mathrm{Im}}
\newcommand{\pair}[1]{\langle #1 \rangle}

% 前置部分包含目录、中英文摘要以及符号表等
\frontmatter

% 目录
\tableofcontents
% 插图目录
%\listoffigures
% 表格目录
% \listoftables

\begin{abstract}
TODO
\end{abstract}

\begin{abstract*}
TODO
\end{abstract*}

% 主体部分是论文的核心
\mainmatter

\ctexset{chapter/pagestyle=fancy}

% 建议采用多文件编译的方式
% 比较好的做法是把每一章放进一个单独的 tex 文件里，并在这里用 \include 导入，例如
%   \include{chapter1}
%   \include{chapter2}
%   \include{chapter3}

\chapter{绪论}

\section{引言}

凝聚态物理中的传统量子多体方法从电子在周期性势场中产生的能带结构出发，通过费曼图微扰地处理库仑相互作用；大体上说，这种范式对应于朗道费米液体理论及其修正\cite{mahan2013many}。
在强关联体系中，费米液体图像失效，在量子多体理论中体现为有相互作用格林函数和无相互作用格林函数无法建立绝热演化的关系，LW泛函出现多值性等现象\cite{Gunnarsson_2017}。
已有多种数值方法可用于不借助微扰论求解强关联系统。对自旋模型，可使用世界线蒙特卡洛、随机级数展开，对电子模型，可使用行列式蒙特卡洛（DQMC），不过这些方法均可能存在符号问题，即在容易想到的基底下，不同系统构型的权重是复数而不是实数，从而无法有效地通过马尔可夫链抽样\cite{sign_problem}。
张量网络方法是近年来发展较快的一种方法，通过构造能够容纳系统基态的纠缠结构的张量网络波函数拟设，通过变分法来获得系统基态。
一维有能隙系统基本上可以使用张量乘积态非常精确地处理（称为DMRG），高维系统的张量网络方法也有很大进展（如PEPS），不过在设计合理的波函数拟设和提高效率方面仍有挑战\cite{orus2019tensor}。

本文讨论的bootstrap技术是一种新兴的非微扰方法\cite{han_matrix,bhattacharya2021,kazakov2021analytic,han_manybody}。
与前述的常规数值方法不同，bootstrap技术不直接处理波函数、算符、（离散）路径积分这些对象，而是通过在待求解的物理量期望值之间建立\emph{解析}的等式和不等式关系，据此它们的取值范围。
通过这种方法，不需要使用正则量子化或是路径积分的语言，我们即可“凭空”求解一个体系。

\section{Bootstrap技术示例：共形Bootstrap}

最为著名的bootstrap方法可能是所谓的共形bootstrap，即针对共形场论（conformal field theory, CFT）的bootstrap\cite{Poland_2016}。
共形对称性对两点和三点关联函数的形式有着强烈的要求：关于标量算符$\mathcal{O}$的两点函数只能够取
\begin{equation}
    \expval*{\mathcal{O}(x) \mathcal{O}(y)} = \frac{1}{{\abs*{x - y}}^{2 \Delta_{\mathcal{O}}}}
    \label{eq:two-point-conformal}
\end{equation}
的形式，其中$\Delta_{\mathcal{O}}$是常数（实际上是算符$\mathcal{O}$的反常量纲），而三点函数只能够取
\begin{equation}
    \langle\mathcal{A}(x) \mathcal{B}(y) \mathcal{C}(z)\rangle = \frac{f_{\mathcal{A B C}}}{|x-y|^{\Delta \mathcal{A}+\Delta_{\mathcal{B}}-\Delta_{\mathcal{C}}}|y-z|^{\Delta_{\mathcal{B}}+\Delta_{\mathcal{C}}-\Delta \mathcal{A}}|z-x|^{\Delta_{\mathcal{C}}+\Delta_{\mathcal{A}}-\Delta_{\mathcal{B}}}}
    \label{eq:three-point-conformal}
\end{equation}
的形式。如果$\mathcal{O}$有自旋$l_{\mathcal{O}}$，分子上可能还会出现一些因子。
在已知两点函数和三点函数之后，可以通过算符乘积展开将更高阶的关联函数递归地计算出来。于是，确定一个CFT需要的数据就是$\{\Delta_{\mathcal{O}}, l_{\mathcal{O}}, f_{\mathcal{A} \mathcal{B} \mathcal{C}}\}$。

我们随后可以向这些数据施加一系列自洽条件。在量子场论中，幺正性会导致光学定理，从而施加一个约束。
另一个约束是算符乘积展开的自洽性：将四点函数以一种方式和另一种方式展开应该得到相同的结果，图示为
\input{cft-ope-consistent.tex}
可以适当放宽其中的一些约束，将它们从等式变成不等式，结合剩下的等式约束，即可确定自洽的CFT的$\{\Delta_{\mathcal{O}}, l_{\mathcal{O}}, f_{\mathcal{A} \mathcal{B} \mathcal{C}}\}$组合。
通过这种方式，在给定一类CFT的基本自由度之后，我们实际上已经知道这整整一类CFT的行为以及理论空间的边界了\cite{Poland_2016,2019}。

在凝聚态物理中，$1+1$维无能隙体系常常可以使用CFT描述，如Luttinger液体及其推广，如霍尔效应边界态\cite{Degiovanni_1998}。
共形bootstrap可以为一个体系的临界行为是不是能够使用CFT描述提供一定提示，如通过比较三维伊辛模型和一类CFT的临界指数，我们有很强的信心表明三维伊辛模型的临界行为可能就是一个落在可行域边界上的CFT\cite{prd2012ising,Poland_2016}。

\section{数值bootstrap}\label{sec:numerical-boostrap-intro}

\subsection{形式理论}\label{sec:formalism}

实际问题中会遇到的模型大多不像CFT那样容易做bootstrap：我们没有像\eqref{eq:two-point-conformal}和
\eqref{eq:three-point-conformal}这么强的对关联函数的约束条件，一般情况下也不能解析地将高阶关联函数转化为低阶关联函数的多项式。
然而，这不意味着bootstrap的思想和一些计算手段不能够适用于非CFT的体系：我们不强求像\eqref{eq:two-point-conformal}和\eqref{eq:three-point-conformal}这样把一个关联函数化简为几个数，但总是可以使用对称性等约束大大缩减一个关联函数所包含的数据；在仅仅由体系的哈密顿量决定的密度矩阵（如能量本征态或是热平衡态）上，我们有
\begin{equation}
    \expval*{O H} = \trace (\rho(H) O H) = \trace(H \rho(H) O) = \trace(\rho(H) H O)  = \expval*{H {O}},
    \label{eq:h-constraint}
\end{equation}
于是可以根据关联函数内的算符和哈密顿量的对易关系获得关联函数之间的联系，类似的，设$C$和$H$对易，即$C$是体系的一个对称性，则也有
\begin{equation}
    \expval*{O C} = \expval*{C {O}},
    \label{eq:sym-constraint}
\end{equation}
于是能够得到另一些关联函数之间的联系；通过将正定性要求作用到不同的算符期望值上，我们可以缩小各个关联函数的取值范围，从而完成bootstrap。
以上思路称为数值bootstrap，可以归结为如下步骤：
\begin{enumerate}
  \item 输入哈密顿量$H$、系统对称性算符集合$\{C_i\}$和参与bootstrap的关联函数涉及的算符组成的集合$\{O_i\}$。
  \item 根据\eqref{eq:sym-constraint}和\eqref{eq:h-constraint}，自动确定不同的$\expval*{O}$之间的关系。
  \item 构建矩阵$M_{ij} = \expval*{O_i^\dagger O_j}$，其中$O_i^\dagger O_j$在经过一定的算符正规排序之后，可以使用$\{O_i\}$为基底展开；$\{O_i\}$张成的算符空间中的形如$O^\dagger O$的算符的期望值不小于零，当且仅当$M$是正定的。
  \item 在第2步的等式约束（这个约束的地位等同于CFT中的算符乘积展开）、$M$必须半正定的约束下，以牵涉到的全体算符期望值为优化变量，最优化
  \begin{equation}
      E \coloneqq \expval*{H} = \sum_i c_i \expval*{O_i}.
      \label{eq:target-function}
  \end{equation}
  这是一个半正定规划（semidefinite programming, SDP）问题。
\end{enumerate}

约束\eqref{eq:h-constraint}和\eqref{eq:sym-constraint}在经过算符正规排序后，都是$\{\expval*{O_i}\}$的仿射变换，而$\expval*{H}$也是$\{\expval*{O_i}\}$的仿射变换。
因此，相应的数值bootstrap问题是一个线性半正定规划问题（以下简称\concept{线性SDP}）。线性SDP问题属于凸优化问题\cite{vandenberghe1996semidefinite,Bofill_2014}，已有SCS\cite{scs,ocpb:16}，CSDP\cite{csdp}，COSMO\cite{Garstka_2021}等成熟的求解器。

在$\rho(E)$实际上对应$H$的某个能量本征态时，\eqref{eq:h-constraint}可以加强为如下形式：
\begin{equation}
    \expval*{HO} = \mel{n}{H O}{n} = E \mel{n}{O}{n} = E \expval*{O}.
    \label{eq:nonlinear-energy}
\end{equation}
在实际计算时，由于$E$是算符$H$的期望值，是未知的，\eqref{eq:nonlinear-energy}的右边将出现$\expval*{O_1} \expval*{O_2}$形式的项，即会出现优化变量的乘积，因此，包含\eqref{eq:nonlinear-energy}约束的数值bootstrap问题将是一个非线性半正定规划问题（以下简称\concept{非线性SDP}）。
由于线性SDP允许系统的密度矩阵不是纯态，线性SDP的$\{O_i\}$的可行域应当比非线性SDP大。
\prettyref{fig:feasibility-compare}是一个离散能级系统
\begin{equation}
    H = \sum_i c_i O_i
\end{equation}
的线性SDP和非线性SDP可行域的示意图。非线性SDP中，可行域有若干彼此不连通的连通分支，每一个均为某个能级上的物理量期望值的范围。
线性SDP的可行域是包含所有非线性SDP可行域的一个凸集。

\begin{figure}
    \centering
    \input{sdp-feasible.tex}
    \caption{线性SDP和非线性SDP：蓝色和绿色区域是非线性SDP的可行域，蓝色区域近似给出基态$E_0$上的物理量期望值，绿色区域近似给出基态$E_1$上的物理量期望值，灰色区域是线性SDP问题的可行域，虚线代表不同$E$对应的$\sum_i c_i \expval{O_i} = E$超平面，其中$c_i$为哈密顿量$H = \sum_i c_i O_i$的系数。}
    \label{fig:feasibility-compare}
\end{figure}

虽然非线性SDP能够让我们看清楚系统的激发态结构，目前尚无足够成熟的非线性求解器能够求解物理上需要的非线性SDP问题\cite{kazakov2021analytic}。
已报道的非线性SDP均仅限于单粒子量子力学，通过递推关系，将所有物理量约化至$E$和$\expval*{x^2}$上，然后暴力搜索\cite{han_matrix,bhattacharya2021}。

相比于同样基于最优化的变分法（包括各种张量网络方法），数值bootstrap有一个独特的优势：只要优化能够正确完成，它能够确定系统能量的\emph{下界}。
这是因为体系的各个物理量期望值必定让\eqref{eq:h-constraint}，\eqref{eq:sym-constraint}和正定性条件成立，即一定在SDP问题的可行域当中，而数值bootstrap给出的能量数值值为可行域中的$\expval{H}$的\emph{最小值}。
因此，数值bootstrap给出的能量数值值必定小于等于能量真实值。
传统的最优化方法给出的则是能量的\emph{上界}。相互比较两种方法的结果，可以将系统基态能量的可能范围确定得非常小。

实际上，在使用传统方法得到能量上界之后，我们还能够进一步确定能量以外的物理量的上下界\cite{han_manybody}。设$E_\text{lb}$是通过bootstrap方法确定的能量下界，而$E_\text{ub}$是通过张量网络方法获得的能量上界，则真实的基态密度矩阵给出的$\expval{H}$显然在这两者之间，即$\rho_0$在集合
\[
    \{ \rho | \trace \rho = 1, \quad E_\text{lb} \leq \expval*{H}_\rho \leq E_\text{ub} \}
\]
中，于是，物理量$O$的基态期望值上下界由
\begin{equation}
    \min_{E_\text{lb} \leq \expval*{H}_\rho \leq E_\text{ub}} \expval{O}_\rho \leq \expval*{O}_{\rho_0} \leq \max_{E_\text{lb} \leq \expval*{H}_\rho \leq E_\text{ub}} \expval{O}_\rho
    \label{eq:operator-bound}
\end{equation}
给出。

\subsection{数值bootstrap的若干应用}

由于bootstrap不依赖于哈密顿量中各项的大小，它显然是处理非微扰问题的有力武器。
已有若干关于不同体系的数值bootstrap研究出现，如关于难以微扰解决的单粒子量子力学问题和矩阵模型\cite{han_matrix,bhattacharya2021,kazakov2021analytic}以及强关联电子模型\cite{han_manybody}。

文献\parencite{bhattacharya2021}使用了以$E$和$\expval*{x^2}$为优化变量、暴力搜索的单粒子量子力学非线性SDP，捕捉到了二势阱模型中的非微扰瞬子效应，并与通过稀薄瞬子假设计算出的基态能量比较，直观展示了稀薄瞬子假设的成立条件；验证了互为对偶的超对称量子力学哈密顿量的谱的确是一致的；验证了$O(N)$向量模型的低能部分在强耦合极限下，基态能量和耦合常数的分数幂次关系，并确认其与解析结果一致。
\parencite{kazakov2021analytic}开发了一套处理矩阵模型的数值bootstrap中的矩阵自由度在大$N$极限下满足的非线性约束
\begin{equation}
    \left\langle\operatorname{Tr} M^{l} \operatorname{Tr} M^{m}\right\rangle=\left\langle\operatorname{Tr} M^{l}\right\rangle\left\langle\operatorname{Tr} M^{m}\right\rangle+\mathcal{O}\left(1 / N^{2}\right)
\end{equation}
的方法，验证了它在求解可以解析处理的矩阵模型时的有效性，并借此解决了无法解析处理的一类二矩阵矩阵模型。%
\footnote{这套方法对非线性SDP的作用可能有限，因为此时\eqref{eq:nonlinear-energy}和\eqref{eq:target-function}联立将导致任意高幂次的非线性约束，而矩阵模型中由于矩阵自由度的非线性约束幂次最多到2。}%
文献\parencite{han_manybody}将线性SDP数值bootstrap技术应用在一维和二维Hubbard模型上，所得结果和常规的DQMC、DMRG等方法吻合。

\section{关于本文}

本文将在\prettyref{chap:oscillator}中复现\parencite{han_matrix}的工作，分别在\prettyref{sec:nonlinear-sdp-oscillator}和\prettyref{sec:linear-sdp-oscillator}中使用非线性SDP和线性SDP方法求解非简谐振子，并用前者为后者做基准测试。
非简谐振子可以通过常规的求解薛定谔方程的方法容易的解决，同时又是一个典型的非微扰系统，因此非常适合用作非微扰方法的玩具模型。

\prettyref{chap:hubbard}章复现了\parencite{han_manybody}的工作，使用线性SDP方法求解一维Hubbard模型。Hubbard模型是最为简单的强关联电子模型，

\chapter{一维非简谐振子的数值bootstrap}\label{chap:oscillator}

\section{一维非简谐振子——一个$0+1$维非微扰场论}

一维非简谐振子
\begin{equation}
    H = p^2 + x^2 + g x^4
\end{equation}
可以看成一个$0+1$维的$\phi^4$量子场论。它常常被用作量子力学中微扰论的例子，但实际上可以证明，其基态能量的微扰级数是发散的\cite{PhysRev.184.1231}。
这个发散可以看成$\phi^4$量子场论中的发散的一个特例。大部分量子场论中，相互作用均导致的微扰级数在最好的情况下也是渐进级数\cite{Jackiw_effective}。%
\footnote{此处所说的是朴素地将物理量展开成关于耦合常数$g$的幂次的级数后，会发现这个级数不收敛。在量子场论中这个级数的每一项都可能不收敛，因为动量积分时发生紫外发散。后一种不收敛和此处的讨论没有直接关系。
然而，\emph{重整化微扰论}——在微扰级数中引入抵消项，物理地看，是使用修饰后的耦合常数取代裸的耦合常数——可以用于消除紫外发散，并且可以在非简谐振子中重复，它在非简谐振子中的收敛性确实在\parencite{Bender-1970uz}中讨论过，结论是，很不幸，它仍然是发散的。}

由于一维非简谐振子归根到底是一个量子力学模型，可以通过求解离散定态薛定谔方程的方法精确地处理它。
它和$3+1$维多体问题的相似性又意味着，用于一般的多体问题的方法也可以用在它上面。
一维非简谐振子的简单形式和它的非微扰本质意味着它是测试多体问题研究方法的一个理想的玩具模型：可以通过比较这些数值或是解析方法和求解离散定态薛定谔方程的结果来预计这些方法的有效性，并分析这些方法为何有效或无效。
一维非简谐振子已被做大量不同的话题的例子，包括泛函重整化群\cite{Nagy-2010fv}、Rayleigh-Schrödinger微扰论的高阶行为\cite{bender199041}、重整化微扰论的收敛性\cite{Bender-1970uz}、量子多尺度分析\cite{Bender_1996}。

\section{非线性SDP优化}\label{sec:nonlinear-sdp-oscillator}

本节我们复现文献\parencite{han_matrix}中对非简谐振子
\begin{equation}
    H = p^2 + x^2 + g x^4
    \label{eq:anharmonic-hamiltonian}
\end{equation}
的非线性SDP计算。由于空间反演不变性，可以确认$n$为奇数时$\expval*{x^n} = 0$。
我们将正规序算符基底$\{O_i\}$选取为$\{x^{2n}\}, n \leq K$。
为此，有必要在不同的$\expval*{x^{2n}}$期望值之间建立非线性递推关系，最终将$n \geq 2$时的所有期望值都转化为能量期望值$E$和$x$的二阶矩$\expval*{x^2}$的多项式。
建立这种递推关系之后，根据矩阵
\begin{equation}
    M_{ij} = \expval*{x^{i + j}}
\end{equation}
的半正定性，即可得到$E$和$\expval*{x^2}$的范围。
由于此时独立的优化变量只有$E$和$\expval*{x^2}$，可以直接通过暴力搜索完成bootstrap。
我们使用Mathematica的\texttt{FindMinimum}函数即可完成整个计算流程。

\subsection{$\expval{x^n}$的非线性递推关系}

本节我们展示如何导出\parencite{han_matrix}中的方程(6)。根据$\expval*{OH} = E \expval*{O}$以及\eqref{eq:anharmonic-hamiltonian}，并取$O = x^{t-1}$，我们有
\begin{equation}
    E \expval*{x^{t-1}} = \expval*{x^{t-1} p^2} + \expval*{x^{t+1}} + g \expval*{x^{t+3}}.
    \label{eq:e-h-o-constraint-oscillator}
\end{equation}
上式中出现了$p$的依赖，这会导致递推关系不封闭；此外，$E$也包含$\expval*{p^2}$的期望值。我们需要设法寻找一个包含$\expval*{x^{t-1} p^2}$和$\langle x^n \rangle$的递推关系。

$E$的期望值中的$\expval*{p^2}$可以通过在$\expval*{\comm{O}{H}} = 0$中取$O = xp$而消去。
我们有
\[
    \comm{p^2}{xp} = p \underbrace{[p, xp]}_{= [p, x] p = - \ii p} + [p, xp] p = - \ii p^2 - \ii p ^2 = - 2 \ii p^2,
\]
\[
    \comm{x^2}{xp} = x\comm{x^2}{p} = x \cdot (2 \ii x) = 2 \ii x^2,
\]
\[
    \comm{x^4}{xp} = x \comm{x^4}{p} = x \cdot (4 \ii x^3) = 4 \ii x^4,
\]
于是约束$\expval*{\comm{O}{H}} = 0$意味着
\[
    - 2 \ii \expval*{p^2} + 2 \ii \expval*{x^2} + 4 g \ii \expval*{x^4} = 0,
\]
于是
\begin{equation}
    \begin{aligned}
        E &= \expval*{p^2} + \expval*{x^2} + g \expval*{x^4} \\
        &= \expval*{x^2} + 2 g \expval*{x^4} + \expval*{x^2} + g \expval*{x^4} = 2 \expval*{x^2} + 3 g \expval*{x^4}.
    \end{aligned}
    \label{eq:e-x-2-x-4}
\end{equation}

我们仍然需要计算一般的$\expval*{x^{t-1} p^2}$。显然，通过在$\expval*{\comm{O}{H}} = 0$中取$O = x^t p$，由于
\[
    \begin{aligned}
        \comm{x^t p}{p^2} &= p \comm{x^t p}{p} + \comm{x^t p }{p} p = p \comm{x^t}{p} p + \comm{x^t}{p} p^2 \\
        &= p \ii t x^{t - 1} p + \ii t x^{t - 1} p^2 = \ii t (\comm{p}{x^{t-1}} p + 2 x^{t-1} p^2) \\
        &= \ii t (- \ii (t - 1) x^{t - 2} p + 2 x^{t-1} p^2) \\
        &= t(t-1) x^{t-2} p + 2 \ii t x^{t-1} p^2,
    \end{aligned}
\]
我们可以在得到的约束条件中看到一个$x^{t-1} p^2$项，但是同样出现了$x^{t-2} p$项，而这个项在\eqref{eq:e-h-o-constraint-oscillator}中是没有出现的。
因此，我们需要另一个只关于$\langle x^n p \rangle$和$\expval*{x^m}$的约束来消去这个项。
这样的约束是容易得到的：注意到
\[
    \begin{aligned}
        \comm{x^s}{p^2} &= p \comm{x^s}{p} + \comm{x^s}{p} p = p \cdot \ii s x^{s-1} + \ii s x^{s-1} p \\
        &= \ii s ( 2 x^{s-1} p + \comm{p}{x^{s-1}} ) = \ii s (2 x^{s-1} p - \ii (s-1) x^{s-2}) \\
        &= 2 \ii s x^{s-1} p + s (s-1) x^{s-2},
    \end{aligned}
\]
而$x^s$和$H$中关于$x$的项当然是对易的。于是$O= x^s, x^t p$的$\expval*{\comm{O}{H}} = 0$约束即可得到将$\expval*{x^{t-1} p^2}$和$\expval*{x^n}$的关系。
$O = x^s$的约束条件我们已经得到，它是
\begin{equation}
    0 = \expval*{\comm{x^s}{H}} = \expval*{\comm{x^s}{p^2}} = 2 \ii s \expval*{x^{s-1} p} + s (s-1) \expval*{x^{s-2}}.
    \label{eq:x-s-constraint}
\end{equation}
我们已经计算了$O = x^t p$和$p^2$的对易关系，它和$x^2, x^4$的对易关系分别是
\[
    \comm{x^t p}{x^2} = x^t \comm{p}{x^2} = x^t \cdot (- 2 \ii x) = - 2 \ii x^{t + 1},
\]
以及
\[
    \comm{x^t p}{x^4} = x^t \comm{p}{x^4} = x^t \cdot (- 4 \ii x^3) = - 4 \ii x^{t + 3}.
\]
这样$O = x^t p$给出的约束就是
\begin{equation}
    t(t-1) \expval*{x^{t-2} p} + 2 \ii t \expval*{t^{t-1} p^2} - 2 \ii \expval*{x^{t+1}} - 4 \ii g \expval*{x^{t+3}} = 0.
    \label{eq:x-t-p-constraint}
\end{equation}
在\eqref{eq:x-s-constraint}中代入$s=t-1$，并联立\eqref{eq:x-s-constraint}和\eqref{eq:x-t-p-constraint}，消去$x^{t-2} p$，就得到
\[
    - t(t-1) \cdot \frac{t - 2}{2 \ii} \expval*{x^{t-3}} + 2 \ii t \expval*{x^{t-1} p^2} - 2 \ii \expval*{x^{t+1}} - 4 \ii g \expval*{x^{t+3}} = 0,
\]
即
\begin{equation}
    4 t \expval*{x^{t-1} p^2} = 4 \expval*{x^{t+1}} + 8 g \expval*{x^{t+3}} - t(t-1)(t-2) \expval*{x^{t-3}}.
\end{equation}
这就消去了\eqref{eq:e-h-o-constraint-oscillator}中的$\expval*{x^{t-1} p}$项，我们得到
\begin{equation}
    4 t E \expval*{x^{t-1}} + t(t-1)(t-2) \expval*{x^{t-3}} - 4 (t+1) \expval*{x^{t+1}} - 4g(t+2) \expval*{x^{t+3}} = 0.
    \label{eq:recursive-nonlinear-sdp-relation}
\end{equation}
这个递推关系中的$x^n$的期望值中，如果其中一个是偶数幂次的，那么全部都是偶数幂次的。在$E$和$\expval*{x^2}$给定后，根据\eqref{eq:e-x-2-x-4}可以计算出$\expval*{x^4}$，于是即可递推出$\expval*{x^6}, \expval*{x^8}, \ldots$，于是就能够构造出全部$\expval*{x^{2n}}$。
这样，即可将矩阵$M_{ij} = \expval*{x^{i+j}}$完全用两个变量$E$和$\expval*{x^2}$表示出来。

至此我们已经构造完成了关于非简谐振子的诸$\expval*{x^n}$的非线性SDP问题，它是
\begin{equation}
    \begin{aligned}
        &\min E, \quad \text{s.t.} \expval*{x^n} = 0 \quad \text{for odd $n$}, \\
        &\quad M_{ij} = \expval{x^{i + j}}, \quad M \geq 0, \\
        &\quad E = 2 \expval*{x^2} + 3 g \expval*{x^4} , \\
        &\quad 4 t E \expval*{x^{t-1}} + t(t-1)(t-2) \expval*{x^{t-3}} - 4 (t+1) \expval*{x^{t+1}} - 4g(t+2) \expval*{x^{t+3}} = 0.
    \end{aligned}
    \label{eq:nonlinear-sdp-problem}
\end{equation}
在实际求解时，需要将$i$和$j$约束在范围
\begin{equation}
    0 \leq i, j \leq K
\end{equation}
中，$K$是对算符幂次上限的一个截断。

\subsection{可行域，基态和第一激发态}

我们在Mathematica中先为变量\texttt{g}赋值，然后执行以下代码：
\lstset{language=Mathematica,basicstyle=\small\ttfamily}
% Code from oscillator-simple-prototype/2022-1-20.nb
\begin{lstlisting}
    expectedX[0] := 1;
    expectedX[2] := x2;
    expectedX[4] := 1/(3 g) (E0 - 2 x2);
    expectedX[u_?EvenQ] := 1 / (4 g ((-3 + u) + 2)) * (
        4 (-3 + u) E0 expectedX[(-3 + u) - 1] 
        + (-3 + u) ((-3 + u) - 1) ((-3 + u) - 2) *
            expectedX[(-3 + u) - 3] 
        - 4 ((-3 + u) + 1) expectedX[(-3 + u) + 1]);

    matPositive[K_] := 
        Table[expectedX[i+j], {i, 0, K}, {j, 0, K}];
\end{lstlisting}
则函数\texttt{matPositive[K]}就给出了表示成变量\texttt{x2}（代表期望值$\expval{x^2}$）和变量\texttt{E0}（代表$E$；这里我们没有使用\texttt{E}，因为Mathematica中符号\texttt{E}默认用于表示自然对数的底）的$M_{ij}$矩阵，参数\texttt{K}即为其幂次截断$K$。
之后，可以通过检查一个正方形区域内，不同的\texttt{E0}和\texttt{x2}值给出的\texttt{matPositive[K]}的特征值是否大于等于零，搜索得到非简谐振子的非线性SDP的可行域。
通过以下代码
\begin{lstlisting}
    RegionPlot[
        AllTrue[Eigenvalues[matPositive[9] /. g -> 1], 
        # >= 0 &], 
        {E0, 1.35, 1.44}, {x2, 0.294, 0.311}, 
    PlotPoints -> 100]
\end{lstlisting}
可以绘制$K$取为9时，$g=1$的非简谐振子（以下均取$g=1$）的非线性SDP可行域的一部分。比照通过其它手段获得的结果（见下一节），可以确定此处的可行域对应非简谐振子的基态。
通过以下代码
\begin{lstlisting}
    FindMinimum[{E0, 
        AllTrue[Eigenvalues[matPositive[9] /. g -> 1], # >= 0 &]}, 
        {{x2, 0.307}, {E0, 1.40}}]
\end{lstlisting}
可以计算给定$K$为9时的\texttt{E0}的极小值，以及此时\texttt{x2}的值。
注意，由于非线性SDP中，属于不同的能级的可行域经常是分散的，在使用\texttt{FindMinimum}寻找极小值点时需要指定初始值，初始值落在哪个能级的可行域中，\texttt{FindMinimum}就给出哪个能级的$E$和$\expval*{x^2}$估计值。

\begin{figure}
    \centering
    \begin{subfigure}{0.48\textwidth}
        \includegraphics[width=\textwidth]{nonlinear-oscillator-nonlinear-sdp-k-7-region.pdf}
        \subcaption{}
    \end{subfigure}
    \begin{subfigure}{0.48\textwidth}
        \includegraphics[width=\textwidth]{nonlinear-oscillator-nonlinear-sdp-k-7-8-9-region.pdf}
        \subcaption{}
    \end{subfigure}
    \caption{(a) 取$K$为7时的基态的$E$和$\expval{x^2}$的范围 (b) $K$为7, 8, 9时的基态的$E$和$\expval{x^2}$的范围}
    \label{fig:ground-state-e-x2-plot}
\end{figure}

\prettyref{fig:ground-state-e-x2-plot}是\texttt{RegionPlot}函数的输出，给出了非线性SDP问题\eqref{eq:nonlinear-sdp-problem}中不同$K$时的基态的$E$和$\expval{x^2}$的可行域。文献\parencite{han_matrix}的图1给出了几乎一样的图形，可以推测作者也是使用Mathematica完成的非线性SDP。
可以看到，随着$K$的增大，可行域快速缩小。实际上，当$K=9$时，可行域已经缩得如此之小，以至于\texttt{RegionPlot}的默认采样密度下，绘制出来的可行域是一片空白；需要将\texttt{PlotPoints}设置到至少100才能够绘制出正确的可行域。

类似的，如\prettyref{fig:first-excited-nonlinear-oscillator}所示，在第一激发态的能量附近做暴力搜索，同样可以发现一个可行域的连通分支。

\begin{figure}
    \centering
    \includegraphics[width=0.48\textwidth]{nonlinear-oscillator-nonlinear-sdp-k-10-first-excited-region.pdf}
    \caption{$K=10$时的第一激发态的$E$和$\expval{x^2}$的范围}
    \label{fig:first-excited-nonlinear-oscillator}
\end{figure}

\input{oscillator-e-x2-table.tex}

\prettyref{tbl:nonlinear-different-k}给出了不同截断下的非线性SDP结果。观察可以发现，随着$K$的提升，基态能量计算结果呈现上升趋势，并且似乎在逐渐收敛。
这和\prettyref{sec:formalism}中所述的基态能量计算值是真实值的下界一致，也表明，通过扩大问题规模，可以系统地提升计算精度。

\subsection{定态薛定谔方程基准测试}

\input{stationary-oscillator-benchmark.tex}

为测试\prettyref{tbl:nonlinear-different-k}的可靠性，我们选择求解定态薛定谔方程来模拟非简谐振子。相应的薛定谔方程为
\begin{equation}
    - \laplacian \psi + x^2 \psi = E \psi, \quad \psi(x \to \pm \infty) = 0.
    \label{eq:schrodinger-oscillator}
\end{equation}
为了做数值求解，采用步长为$\Delta x$的有限差分格式，则$\laplacian$近似为一个矩阵，其中
\begin{equation}
    \laplacian_{i, i} = -2 / \Delta x^2, \quad \laplacian_{i, i - 1} = \laplacian_{i, i+1} = 1 / \Delta x^2,
\end{equation}
其余矩阵元为零，$\hat{x}$算符近似为一个对角矩阵，$x_{ii}$为$i$点的坐标。
进一步，将求解域限制在$- L \leq x \leq L$上。设求解域被离散化为$N$个点。在$L$充分大时，可以认为波函数在求解域的两端为零，于是在$i=1$和$i = N$时分别有
\begin{equation}
    \laplacian_{1, 1} = -2, \quad \laplacian_{1, 2} = 1, \quad \laplacian_{N, N} = -2, \quad \laplacian_{N, N-1} = 1.
\end{equation}
于是，$\laplacian$被截断为一个$N \times N$维矩阵。求解\eqref{eq:schrodinger-oscillator}等价于对角化矩阵$-\laplacian + x^2$。
我们采用Arpack-NG库（用于大型矩阵对角化的Arpack库的一个实现）\cite{arpackcode}的Julia封装Arpack.jl\cite{arpackjl}完成这项工作。取$L=10$以及不同的$\Delta x$，使用Arpack.jl计算$-\laplacian + x^2$的最低本征态，即系统基态，所得结果见\prettyref{tbl:stationary-benchmark}。
表中不同的$\Delta x$对应的波函数均平滑。
可以看到，\prettyref{tbl:nonlinear-different-k}和\prettyref{tbl:stationary-benchmark}给出的值非常接近。取两者中计算精度最高的值（\prettyref{tbl:nonlinear-different-k}中$K=12$和\prettyref{tbl:stationary-benchmark}中的$\Delta x = 0.005$），计算相对偏差，发现$E$的相对偏差为\num{1.1e-4}，$\expval*{x^2}$的相对偏差为\num{1.0e-4}，两者符合程度较好。

\subsection{计算$\langle x^m p^n \rangle$参考值}

\begin{figure}
    \centering
    \includegraphics[width=0.6\textwidth]{oscillator-expectations.pdf}
    \caption{非简谐振子的非线性SDP计算得到的$K=11$时的$\langle x^m p^n \rangle$参考值}
    \label{fig:oscillator-expectation}
\end{figure}

% calculate-all-correlation-functions-in-xp-oscillator-for-benchmark-4.nb
在已经获得了精度较高的$E$和$\expval*{x^2}$数据之后，我们可以据此计算所有$\expval*{x^m p^n}$值。
在Mathematica中直接列出所有的$\expval*{\comm{O}{H}} = 0$并使用\texttt{Solve}求解是非常缓慢的，采用如下方法可以较快地获得任意$m, n$的$\expval*{x^m p^n}$。
注意到，$x^n$和$H$的对易子就是$x^n$和$p^2$的对易子，其正规序形式$p$的次数最高为1；$x^n p$和$H$的对易子中$p$的次数最高的项由$x^n p$和$p^2$的对易子贡献，$p$的次数最高为2……如此重复，$x^m p^n$和$H$的对易子的正规排序形式中，$p$的次数最高为$n+1$。
因此，可以使用\eqref{eq:recursive-nonlinear-sdp-relation}计算出所有的$\expval*{x^m}$型期望值，然后使用这些数据连同$\expval*{\comm{H}{x^m}} = 0$给出的约束条件，计算出所有的$\expval*{x^m p}$型期望值，然后引入$\expval*{\comm{H}{x^m p}} = 0$型约束条件，计算所有的$\expval*{x^m p^2}$型期望值……如此重复，即可计算出次数小于某个截断的所有的$\langle x^m p^n \rangle$期望值。
\prettyref{fig:oscillator-expectation}展示了一些这样计算出的期望值。应注意，如果要使用这些数据做其它SDP程序的基准测试，必须取更多的小数点后位数。

\section{线性SDP优化}\label{sec:linear-sdp-oscillator}

本节讨论如何使用线性SDP实施非简谐振子的数值bootstrap。在\prettyref{sec:nonlinear-sdp-oscillator}中，我们能够分析第一激发态处的物理量，而在线性SDP中我们只能讨论基态性质。
然而，由于非线性SDP在大规模问题上是不可行的（见\prettyref{sec:numerical-boostrap-intro}的讨论），线性SDP对凝聚态体系基本上是唯一的选择。
因此，本节将非简谐振子当作一个玩具模型，用它演示如何做线性SDP，为在凝聚态体系中做数值bootstrap做准备。

\subsection{对易子和等式关系的符号计算}

非简谐振子线性SDP的问题可以叙述如下：设
\begin{equation}
    O_i^\dagger O_j = \sum_{k} c_{ij}^k O_k,
\end{equation}
\begin{equation}
    \comm{H}{O_i} = \sum_j h_j^k O_k,
\end{equation}
则我们有
\begin{equation}
    \begin{aligned}
        &\min E, \quad \text{s.t.} \quad E = \expval*{p^2} + \expval*{x^2} + g \expval*{x^4}, \\
        &\quad M_{ij} \coloneqq \sum_k c^k_{ij} \expval*{O_i}, \quad M \geq 0, \quad M_{ij} = M_{ji}^* , \\
        &\quad \sum_j h_j^k \expval*{O_k} = 0.
    \end{aligned}
    \label{eq:oscillator-linear-sdp}
\end{equation}
注意，在以上问题中，$\expval*{O_i}$应该\emph{整体}当成一个优化变量；线性SDP求解器不关心它是否是某个物理量的期望值。
约束条件$M_{ij} = M_{ji}^*$保证了$\expval*{O^\dagger} = \expval*{O}^*$。

使用$\{x^m p^n\}$满足$0 \leq m, n \leq L$的子集，按照$\expval*{O_i^\dagger O_j}$的方法构建$M$矩阵。
这可以保证$\{x^m p^n\}$中的每个算符都出现在$M$矩阵中，不至于浪费优化变量。
显然，$M$矩阵的边长为$(L+1)^2$。

此时没有类似\eqref{eq:recursive-nonlinear-sdp-relation}这样较为精简的递推公式，$c_{ij}^k$和$h_j^k$的计算需要自动进行。
我们取$\{O_i\}$为$\{x^m p^n\}$，并将其张成的空间设为$\mathcal{C}$。我们对$\{x^m p^n\}$施加如下截断：要求
\begin{equation}
    0 \leq m, n \leq 2 L,
\end{equation}
其中$L$是一个正整数。我们将$x^m p^n$算符编号为$m(2L+1) + n$，这样，基底$\{x^m p^n\}$的编号就从0一直连续取到$(2L+1)^2-1$，$\mathcal{C}$是一个$(2L+1)^2$维的线性空间。
我们有McCoy公式\cite{McCoyOnCF}
\begin{equation}
    {\left[{ {x}}^{n},{ {p}}^{m}\right]=\sum _{k=1}^{\min \left(m,n\right)}{{\frac {-\left(-i\hbar \right)^{k}n!m!}{k!\left(n-k\right)!\left(m-k\right)!}}{ {x}}^{n-k}{ {p}}^{m-k}}},
\end{equation}
将这个公式代入
\begin{equation}
    {x^{m_1} p^{n_1}}{x^{m_2} p^{n_2}} = x^{m_1 + m_2} p^{n_1 + n_2} - x^{m_1} \comm{x^{m_2}}{p^{n_1}} p^{n_2}
    \label{eq:oscillator-normal-ordering-scheme}
\end{equation}
等式右边就已经是正规排序的了。于是，可以实现一个函数 \texttt{xpopstr\_normal\_ord} ，输入$m_1, n_1, m_2, n_2$，输出\eqref{eq:oscillator-normal-ordering-scheme}右边在基底$\{x^m p^n\}$下的系数。于是，我们就能够自动计算$p^{n_1} x^{m_1} x^{m_2} p^{n_2}$，于是$c^k_{ij}$即可自动计算。
通过将${x^{m_1} p^{n_1}}{x^{m_2} p^{n_2}}$和${x^{m_2} p^{n_2}}{x^{m_1} p^{n_1}}$的系数向量相减，$\comm{O_1}{O_2}$的系数向量也可以自动计算，于是$h^k_j$也可以自动计算。
这就给出了基底$\{x^m p^n\}$下自动计算$h_j^k$和$c^k_{ij}$的方法。
注意，对一些$\mathcal{C}$中的$O$，$\comm{O}{H}$可能在$\mathcal{C}$外，此时我们丢弃它对应的等式约束。

\subsection{构建优化问题}

我们使用JuMP 0.22.3\cite{DunningHuchetteLubin2017}和COSMO 0.8.5\cite{Garstka_2021}构建并求解优化问题\eqref{eq:oscillator-linear-sdp}。
JuMP是一个优化器前端，可以通过\eqref{eq:oscillator-linear-sdp}这样的记号，高可读性地构建优化问题，而无需手动将\eqref{eq:oscillator-linear-sdp}中的约束组装成系数矩阵再传给优化器。
COSMO是一个大规模凸优化问题求解器，适用于线性SDP问题。

由于COSMO不支持复数变量，在构建优化问题时需要将$\langle x^m p^n \rangle$的实部和虚部声明为不同的变量。
注意到在一维束缚态问题中，如果$m+n$是奇数，那么$\expval*{x^m p^n} = 0$，否则，如果$m$是偶数，那么$\expval*{x^m p^n}$是纯实数，如果$n$是奇数，那么$\expval*{x^m p^n}$是纯虚数。
因此，可以只对$m+n$为偶数的那些$\expval*{x^m p^n}$声明优化变量，且对每个期望值只声明一个变量，代表其实部或虚部。

在声明完优化变量之后，可以使用JuMP提供的\texttt{@constraint}宏，对这些变量施加\eqref{eq:oscillator-linear-sdp}中由$h_j^k$确定的那些约束。

由于\eqref{eq:oscillator-linear-sdp}中的$M$矩阵包含复数，在JuMP中构建优化问题时，需要把它的每一个矩阵元$M_{ij}$替换为
\begin{equation}
    \Re(M_{ij}) \pmqty{1 & 0 \\ 0 & 1} + \Im(M_{ij}) \pmqty{0 & -1 \\ 1 & 0}.
    \label{eq:complex-to-real}
\end{equation}
我们可以在JuMP中声明一个边长为$2(L+1)^2$的半正定矩阵变量，然后使用\texttt{@constraint}宏将$M_{ij}$和$\{\expval*{O_i}\}$联系起来。
由于在大部分线性SDP求解器中，被声明为半正定的矩阵变量一定是对称的%
\footnote{可以运行几次迭代，然后用\texttt{value.(M)}检查此时的\texttt{M}的值。计算其本征值，会发现有绝对值很小的负值，但是比较它和它的转置，会发现两者完全相同。}%
，将$M_{ij}$的每个矩阵元都和$\{\expval*{O_i}\}$联系起来之后，$\expval*{O^\dagger} = \expval*{O}^*$的约束就自动被施加了。

\subsection{使用非线性SDP为线性SDP做基准测试}\label{sec:oscillator-benchmark}

由于已经有了非线性SDP计算出的数据，非简谐振子线性SDP程序的调试将变得容易很多，因为可以直接检查非线性SDP的计算结果是否满足线性SDP程序中的各种约束，从而检查程序是否正确。

在完成线性SDP的程序开发后，使用\texttt{primal\_feasibility\_report}函数可以检查一个特定的数据点是否在可行域中，以及如果不在可行域中，各个约束被违反了多少。
我们可以将Mathematica中的计算结果\prettyref{fig:oscillator-expectation}导出为一个Julia的\texttt{Dict}对象，将它传给\texttt{primal\_feasibility\_report}。
结果发现，在$L=5$时，等式约束被违反的数值的量级是\num{1e-11}，其主要来源是导出数据时的舍入误差。
% 见oscillator-simple-prototype/labbook.md的2022.3.26的记录
目前JuMP和COSMO尚未配合得足够好，无法直接通过\texttt{primal\_feasibility\_report}检查$M$矩阵的半正定性，但是直接根据\prettyref{fig:oscillator-expectation}，在线性SDP程序中计算$M$矩阵，发现$L=5$时，它有负本征值，但其量级最大在\num{6e-3}，而最大的本征值量级为\num{1e5}，于是可以认为线性SDP程序对M矩阵的计算也是正确的。

\subsection{计算结果与收敛性问题}\label{sec:convergence-problem}

\input{linear-sdp-oscillator-result.tex}

$L = 2, 3, 4$时的线性SDP计算结果见\prettyref{tbl:linear-sdp-oscillator-result}。%
\footnote{本例中使用的代码见\url{https://github.com/wujinq/numerical-boostrap/blob/main/oscillator-simple-prototype/jump-oscillator-4-small-scale.jl}。}%
可以看到，在$L=2, 3$时，使用非常短的时间，线性SDP就能够达到\prettyref{tbl:nonlinear-different-k}中$K=10$的精度。
在联想T480笔记本电脑上，$L=10$的非线性SDP需要耗费几分钟，而线性SDP只需要两秒，体现了SDP求解器相对暴力搜索的巨大优势。

% 见2022.4.27的oscillator-simple-prototype\labbook.md
然而，$L=4$时，存在严重的收敛性问题。COSMO的默认容差（线性约束被违反的程度——见COSMO的文档\parencite{cosmo-method}）无法达到要求的精度：程序运行至19698迭代后，能量达到25.31，提示收敛。
% 见2022.3.22的oscillator-simple-prototype\labbook.md
$L=5$时COSMO的默认容差同样无法达到要求的精度：在经过漫长的3353517次迭代之后，程序运行到能量约为13.9，提示收敛。
% 见2022.4.20的oscillator-simple-prototype\labbook.md
改用CSDP求解器，会提示“Lack of progress”；SCS求解器直接报告问题不可解。

% 见2022.4.29的oscillator-simple-prototype\labbook.md
将容差参数\texttt{eps\_rel}从默认值\num{1e-5}缩小至\num{1e-10}，$L=4$时的线性SDP能够收敛，但是耗时增长高得可观。
检查优化器输出，发现与$L=2, 3$时的优化器输出相比，至少存在以下几个不同。$L=4$时，需要约50000迭代让能量到达10左右，在此之前会经历能量上百的阶段，而$L=2, 3$时没有这种情况，能量只需要25迭代就到达了非简谐振子的基态能量的量级。
$L=2, 3, 4$的问题中，均有出现能量振荡的现象，这本身是正常的，因为大规模求解器不会施加硬约束，半正定约束和线性约束都是通过向目标函数引入柔化的指示函数完成的\cite{cosmo-method}，因此，一个让能量下降的优化过程很可能以轻微违反各种约束为代价，后续收紧约束的优化过程当然也可能会让能量上升。然而，在$L=4$的优化过程中，会出现非常长周期的能量振荡：可能出现几万个迭代的能量上升，然后是一段能量下降的过程，接着又是长时间的能量振荡。
在能量已经接近目标时，优化过程非常慢。例如，7000000迭代时，能量已经到达1.54，然而还要经过比这多一个量级的迭代数目才能够最终收敛。
推测这也是加细约束过程中的能量振荡导致的，只不过振荡的量级小于\num{1e-4}，没有在优化器输出中显示。

% 见2022.4.7的oscillator-simple-prototype\labbook.md
将容差参数\texttt{eps\_rel}从默认值\num{1e-5}缩小至\num{1e-10}后，$L=5$时的线性SDP未能完成。在经过了80000000个迭代之后，能量到达5.3690，此时系统能量仍然在前述和收紧约束有关的缓慢振荡中。

在共形bootstrap中，常规的64位浮点数有时无法满足精度要求，即舍入误差可能在计算过程中放大，导致一个点是否在可行域中无法正确判断，从而大小合理的容差难以达到；放松容差要求，则可能出现优化不充分的情况。
因此，支持任意精度的优化算法是必要的\cite{conformal-sdp}。为了检查是否在本例中出现了这种情况，而可以将$L=2, 3$的优化问题中的浮点数精度人为调小，观察计算收敛性。
不幸的是，JuMP目前不支持调整浮点数精度%
\footnote{见此处的讨论：\url{https://discourse.julialang.org/t/use-low-precision-float-type-in-jump/80332}。}%
，因此眼下调整浮点数精度需要将代码重写为稍微低层一些的MathOptInterface\cite{legat2021mathoptinterface}代码，由于时间因素，非简谐振子的线性SDP中的收敛性问题来自何处的讨论只能留给未来的研究了。

\chapter{Hubbard模型的数值bootstrap}\label{chap:hubbard}

\section{Hubbard模型简介}

本章讨论Hubbard模型
\begin{equation}
    H = - t \sum_{\pair{\vb*{i}, \vb*{j}}, \sigma} c^\dagger_{\vb*{i} \sigma} c_{\vb*{j} \sigma} + U \sum_{\vb*{i}} n_{\vb*{i} \uparrow} n_{\vb*{j} \downarrow}
\end{equation}
的线性SDP数值bootstrap。Hubbard模型是一个格点强关联电子模型，描述了一个声子作用可忽略，费米面附近只有一条可以使用紧束缚模型描述的能带，原位（on-site）库伦排斥最为重要，长距离库伦排斥不重要的系统。
在能带半填充，$U$较大时，Hubbard模型退化为海森堡模型，其中电子定域而无法自由移动，从而电荷自由度（即电子数自由度）不再是低能自由度，只有每个格点上的自旋自由度是基本自由度。
从能带论的角度，这可以理解为强烈的相互作用导致出现能带劈裂，费米能级落在禁带上，从而体系成为Mott绝缘体。
因此，Hubbard模型对铁磁学显然非常重要。
此外，掺杂（从而费米能级位置发生变动）的Hubbard模型可能能够从完全的排斥相互作用出发产生电子配对，从而也是高温超导的可能机制之一。
总之，Hubbard模型的简单性以及它的丰富物理含义让它成为了研究强关联电子系统的基础\cite{fradkin2013field}。

DMRG方法可以在开边界条件下以相当高的精度计算各种一维强关联格点系统\cite{Schollw_ck_2011}，
此外，使用Bethe拟设可以严格求解一维Hubbard模型以及其它若干强关联电子模型\cite{PhysRevLett.20.1445,korepin1994exactly}。
这些工作使得一维Hubbard模型成为了测试量子多体方法适用性的理想玩具模型。一维Hubbard模型也可以用于粗略地复现一维铜基超导体$\mathrm{Sr}_{2} \mathrm{CuO}_{3}$链、聚二乙炔等一维系统，虽然已知的类似Hubbard模型的系统往往涉及不止一条能带（由于Peierls转变），并且重要的库仑相互作用通道都不只原位库伦排斥。
在\prettyref{sec:one-dimensional-hubbard}中，我们尝试复现\parencite{han_manybody}中关于一维Hubbard模型的部分。

二维Hubbard模型的数值研究具有更加直接的物理意义（例如，它的相图和铜基超导体类似，在掺杂时存在赝能隙\cite{2d-hubbard-numerical}），也更具挑战性。一些二维系统——包括Hubbard模型——仍然可以使用DMRG方法非常有效地处理，但计算开销较大\cite{Stoudenmire_2012}。
朴素地对Hubbard模型做DQMC模拟会遇到符号问题，需要通过选择适当的基底等方式去除\cite{pgp-sign}。

\section{一维Hubbard模型的数值bootstrap}\label{sec:one-dimensional-hubbard}

\subsection{算符空间截断}

\begin{figure}
    \centering
    \input{1d-lattice-indexing.tex}
    \caption{一维简单晶格的格点编号方案}
    \label{fig:1d-lattice-index}
\end{figure}

我们遵从\parencite{han_manybody}中的做法，使用以下标准来截断算符空间：我们以正规排序的形如
\begin{equation}
    O = c^\dagger_{{x}_1 \sigma_1} c^\dagger_{x_2 \sigma_2} \cdots c^\dagger_{x_m \sigma_m} c_{x_{m+1} \sigma_{m+1}} \cdots c_{x_{n} \sigma_n}
    \label{eq:hubbard-operator-form}
\end{equation}
算符乘积为基底，只有满足
\begin{equation}
    l(O) \coloneqq n + \sum_{i=1}^n \left\| x_{i} \right\|_1 \leq K
    \label{eq:operator-space-criteria}
\end{equation}
的算符被纳入我们考虑的算符空间。为了避免重复计数，我们将每个格点赋予一个编号（见\prettyref{fig:1d-lattice-index}；由于），并且要求\eqref{eq:hubbard-operator-form}的产生算符和湮灭算符部分中，从左往右格点编号均依次增大。
这么定义正规排序的原因是这是后面做符号计算使用的QuantumAlgebra.jl包（见\prettyref{sec:symbolic-hubbard}）定义正规排序的方法。可以通过如下代码验证这一点：
\begin{verbatim}
    julia> normal_form(c(1) * c(2))
    c(1) c(2)

    julia> normal_form(cdag(1) * cdag(2))
    c†(1) c†(2)
\end{verbatim}

注意到，由于$O = O_1 O_2$，我们有
\begin{equation}
    l(O) = l(O_1) + l(O_2),
\end{equation}
因此，可以首先构造出满足$l(O) \leq K$的所有湮灭算符乘积，然后将$c$替换成$c^\dagger$就得到了满足$l(O) \leq K$的所有产生算符乘积，两者的乘积中包含所有满足$l(O) \leq K$的产生湮灭算符乘积。
这就完成了截断过的算符空间的构造。

在构造满足$l(O) \leq K$的所有产生算符乘积时，我们当然不可能遍历无数个格点，也不能够遍历任意长的产生湮灭算符乘积，不过\eqref{eq:operator-space-criteria}显然意味着
\begin{equation}
    \max \| x_i \|_1 \leq K - 1, \quad n \leq K.
    \label{eq:inequality-hubbard-opstr}
\end{equation}
因此，可以如下搜索满足条件\eqref{eq:operator-space-criteria}的所有湮灭算符乘积：我们列出所有满足$\abs*{x_i} \leq K - 1$的格点$x_i$，在每个格点上放置如下四种状态之一：没有算符，有一个自旋向上的湮灭算符，有一个自旋向下的湮灭算符，同时有自旋向上和向下的湮灭算符，然后筛去不满足\eqref{eq:operator-space-criteria}的情况即可。
我们记所有满足此条件的算符构成的集合为$\mathcal{C}$，它张成的空间就是我们在bootstrap中考虑的算符空间。

\subsection{等式约束和半正定约束的构建}\label{sec:symbolic-hubbard}

我们使用QuantumAlgebra.jl 1.1.0包\cite{Sanchez-Barquilla2020,QuantumAlgebra.jl}自动完成费米子算符的对易关系和正规排序计算。
调用QuantumAlgebra.jl包，并调用\texttt{@fermion\_ops}宏声明湮灭算符\texttt{c}后，即可使用\texttt{c(args...)}和\texttt{cdag(args...)}两个函数得到标签为\texttt{args}的湮灭算符和产生算符。
根据\prettyref{fig:1d-lattice-index}为格点编号，并使用\texttt{1}表示自旋向上的算符，\texttt{-1}表示自旋向下的算符。
例如，取原点为1号格点，则$c^\dagger_{x = 1, \uparrow}$在程序中对应\texttt{cdag(2,1)}。%
\footnote{
    由于Julia支持unicode变量名，更加规范的做法本应是将自旋向上就使用$\uparrow$表示。然而，目前的QuantumAlgebra.jl版本将传递给它的标签中能够做合法的变量名（包括字符串）的东西都看成抽象的、值可变的指标，其结果是没有办法区分\texttt{cdag(i,↑)}和\texttt{cdag(i,↓)}。
    我们不得不使用整数来表示自旋标签（浮点数目前不受支持）。
}%

本例中的等式约束来自哈密顿量$H$、总自旋$S^z$、总粒子数$N$、平移对称性、空间反演对称性。前三个对称性导致的约束通过计算对易关系得到：我们构造一个容纳了$\mathcal{C}$中出现的所有格点的格子上的近似哈密顿量、总自旋、总粒子数，使得它们和$\mathcal{C}$中任何一个算符的对易子都等于后者和真正的$H, S^z, N$的对易子，然后使用QuantumAlgebra.jl包计算对易子即可。
平移对称性和空间反演对称性原则上也可以通过对易子计算得到，但是此处应注意，平移操作的生成元不是
\[
    \sum_{i, \sigma} c^\dagger_{i \sigma} c_{i + 1, \sigma},
\]
空间反演对称操作也不是
\[
    \sum_{i, \sigma} c^\dagger_{i \sigma} c_{-i, \sigma}.
\]
这两个算符和含有超过两个算符的产生湮灭算符乘积的对易子是不正确的。因此，直接修改QuantumAlgebra.jl算符上的格点标签，将5变成3，3变成1，1变成2……以及将3变成2，5变成4……然后计算格点变换前后的算符的差，是得到平移对称性约束和空间反演对称性约束方程的最简单的方法。

在完成所有对易关系和正则排序计算后，可以将其中的产生湮灭算符乘积替换为相应的JuMP优化变量。
与非简谐振子的情况不同，本例中所有算符期望值都是实的%
\footnote{
    在粒子数表象中思考问题即可看清楚这一点：无论是$c^\dagger_{i \sigma} c_{i + 1, \sigma}$还是$n_{i \uparrow} n_{i \downarrow}$都是实矩阵，哈密顿量中又不存在复数，因此整个哈密顿量都是实的，其本征值也是实的，并且$c^\dagger \cdots c^\dagger c \cdots c$也是实矩阵，从而其期望值也是实的。

    量子力学问题涉及不可数无穷维算符，并且动量算符不是实的，因此不能保证算符期望值是实的，因此在构建线性SDP问题时反而需要\eqref{eq:complex-to-real}的额外工序。
}%
，从而无需将算符的虚部声明为优化变量，也无需做\eqref{eq:complex-to-real}变换。

由于$S^z$和$N$产生的约束条件全部体现为不满足自旋和粒子数守恒的一个单独的产生湮灭算符乘积的期望值为零，我们可以不声明和这些算符的期望值有关的优化变量，而直接用零填充它们占据的位置。
另一个无需声明JuMP变量而直接用数值填充的变量期望值是恒等算符的期望值；如果恒等算符的期望值被声明为一个JuMP变量，那么全部$\expval*{\comm{O}{H}} = 0$等式约束就都是线性的而非仿射的，从而可以往全部JuMP变量上乘一个正数而保持所有约束成立，导致总能量无下界。

我们仍然需要引入一个额外的约束：系统中的总电子数。由于系统具有平移对称性，可以将每个格点上的$\expval*{n_i}$变量替换为平摊到各个格点上的电子数期望值；在半填充的情况下，即为1。

\subsection{DMRG基准测试}

我们需要确保前述程序是正确的，换而言之，需要确定我们传递给求解器的bootstrap问题真的是一维Hubbard模型的线性SDP问题。
测试其正确性的方法和\prettyref{sec:oscillator-benchmark}中是一样的，都是检查使用其它方式计算出的关于有待bootstrap的模型的数据是否符合我们传递给求解器的约束。
一维体系的DMRG计算已经非常成熟，本文使用ITensors.jl 0.2.9\cite{itensor,itensor-lib}，使用其提供的\texttt{Electron}型张量指标、\texttt{MPO}函数、自带的产生湮灭算符定义，即可将一维Hubbard模型在有限格点上的哈密顿量自动转化为矩阵乘积算符，然后完成DMRG计算。
取一段100个格点的一维格子，在其上运行保证量子数守恒（为了确保系统中填充的电子数正确）的\texttt{Electron}型张量指标，即可计算得到张量乘积态拟设下的近似基态，将\prettyref{fig:1d-lattice-index}的1号格点取在中间部分，计算$\mathcal{C}$中各个算符的期望值（注意，保证量子数守恒的DMRG中，被$S^z$和$N$引入的约束要求为零的算符均没有定义），即可得到用于基准测试的数据，重复\prettyref{sec:oscillator-benchmark}中的操作，即可完成对一维Hubbard模型线性SDP程序的基准测试。

在使用DMRG做基准测试时应注意DMRG不严格保证平移和镜像对称性的成立，因此，来自这两个对称性的约束将被违反得较为厉害，这并非说明优化问题构建有误。

\subsection{计算结果}

% 2022.5.9的hubbard-1d-prototype\labbook.md
可能多少有些出人意外的，一维Hubbard模型的线性SDP的收敛性要明显好过非简谐振子；本文测试的所有情况——最高到$K=12$——下，求解器均迅速地收敛了。
$K=10$时有约11万个优化变量，但是求解器在几分钟内就完成了计算；$K=12$时约有70万个优化变量，但是20分钟内计算也完成了。事实上，本例使用的程序的主要的耗时在于线性SDP之前，将QuantumAlgebra.jl中的算符转化成JuMP约束的步骤。
尚不清楚为什么一维Hubbard模型的线性SDP的收敛性更加好，但是可以确定这和一维Hubbard模型基态期望值全部是实数有关：如果我们忽视这个条件，而为每个$\mathcal{C}$中算符的期望值的实部和虚部分别声明变量，并且使用\eqref{eq:complex-to-real}构造$M$矩阵，那么即使对一个较小规模的问题（如$K=6$），COSMO求解器一开始就会报告“not feasible”。

\input{hubbard-1d-energy-double-occ-table.tex}

计算结果展示如\prettyref{tbl:hubbard-1d-linear-sdp}。由于时间所限，本文没有做\eqref{eq:operator-bound}，因此表中的双占据算符期望值只是普通的数值值，不保证是上界或是下界。
可以看到线性SDP给出的结果是精确解的下界，并且提升$K$可以收紧下界；双占据数值值可以较为精确地计算。$U$较大时，数值bootstrap给出的下界较紧。
直观地看，这应该是因为$U$较大时，电子倾向于定域，从而只有较为局域的算符有较大的期望值；由于涉及长距离跃迁的算符无法通过\eqref{eq:operator-space-criteria}的筛选，在$U$较大时，不需要将$K$取得很大，$\mathcal{C}$中的算符就足够完成一次较为精确的bootstrap。

\section{二维Hubbard模型的数值bootstrap}

\subsection{算符空间的选取和截断}

\begin{figure}
    \centering
    \input{2d-square-lattice-indexing.tex}
    \caption{二维正方晶格的格点编号方案}
    \label{fig:site-index-2d}
\end{figure}

我们还是以\eqref{eq:operator-space-criteria}为截断算符空间的标准。如何搜索满足这个条件的算符需要一些额外的说明。
在二维情况下，直接暴力枚举满足\eqref{eq:inequality-hubbard-opstr}是非常低效的，因为涉及到的格点数目大体上为$K^2$量级，于是需要遍历$4^{K^2}$量级的湮灭算符乘积。
为了保证构成$H$的算符出现在截断后的算符空间中，至少需要$K=4$，于是需要遍历\num{4e9}个算符，而且随着$K$增大指数增长。
我们使用深度优先搜索来简化计算，在\prettyref{fig:site-index-2d}中按照格点编号从小到大的顺序，依次放置以下四种算符组合之一：没有算符，有一个自旋向上的湮灭算符，有一个自旋向下的湮灭算符，同时有自旋向上和向下的湮灭算符。
一旦发现$l(O) \leq K$条件不满足，立即“剪枝”，并且切换到下一个算符组合。
如此可以大大加速算符空间的搜索速度。

\chapter{总结与展望}


% 后置部分包含参考文献、声明页（自动生成）等
\backmatter

% 打印参考文献列表
\printbibliography

\chapter{致\quad 谢}

\chapter{附\quad 录}

\end{document}
