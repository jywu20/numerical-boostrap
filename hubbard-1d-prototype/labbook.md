# 2022.4.30

先从一维Hubbard做起吧。

在改代码期间我强烈感到有必要写格点无关的程序，不过这些代码应该也不会用到别的地方了，so……

使用`2022-4-30-run-1.sh`提交程序。目前的配置：
```julia
const working_path = "./"
const output_name = "2022-4-30-run-1-res"

const full_output_name = working_path * output_name

# If there exists working_path * output_name already, throw an error
const no_conflict = false

# Display operators involved in the bootstrap process
const show_hubbard_opstr_basis = false 

#endregion

#region model parameter and cutoff

# The hopping parameter and local repulsion  
U = 4.0
t = 1.0

# l(O) ≤ K cutoff
K = 5
site_num = 2K + 1

# When this flag is `true`, no actual optimization will be done. For debugging only.
no_optimization = false 
max_iter = 10000
```

提示infeasible。

应注意此处$K$不能小于4，否则哈密顿量无法在算符空间中表示出来。

好像$K=4$也是会出问题的。
```
ERROR: LoadError: MethodError: Cannot `convert` an object of type Nothing to an object of type Array{Complex{Float64},1}
Closest candidates are:
  convert(::Type{Array{T,N}}, ::StaticArrays.SizedArray{S,T,N,N,Array{T,N}}) where {S, T, N} at C:\Users\wujin\.julia\packages\StaticArrays\N3rrI\src\SizedArray.jl:120
  convert(::Type{Array{T,N}}, ::StaticArrays.SizedArray{S,T,N,M,TData} where TData<:AbstractArray{T,M} where M) where {T, S, N} at C:\Users\wujin\.julia\packages\StaticArrays\N3rrI\src\SizedArray.jl:114
  convert(::Type{T}, ::AbstractArray) where T<:Array at array.jl:554
  ...
Stacktrace:
 [1] setindex!(::Array{Array{Complex{Float64},1},2}, ::Nothing, ::Int64, ::Int64) at .\array.jl:849
 [2] top-level scope at d:\Projects\numerical-boostrap\hubbard-1d-prototype\operator-algebra.jl:158        
in expression starting at d:\Projects\numerical-boostrap\hubbard-1d-prototype\operator-algebra.jl:152  
```
看起来这里头的问题是，用于span出M矩阵的算符中选两个做乘积得到的某些算符并不在算符空间中。

# 2022.5.4

将$K=5$时的约束和导致这些约束的算符打印出来：（见`2022-5-3-run-1-res`）
```
1     0 = 0
c†(11)     -c†(21) - c†(31) - 4 c†(1-1) c†(11) c(1-1) = 0
c†(1-1)     -c†(2-1) - c†(3-1) + 4 c†(1-1) c†(11) c(11) = 0
c†(1-1) c†(11)     4 c†(1-1) c†(11) - c†(1-1) c†(21) - c†(1-1) c†(31) + c†(11) c†(2-1) + c†(11) c†(3-1) = 0
c†(31) c(31)     -c†(11) c(31) + c†(31) c(11) + c†(31) c(51) - c†(51) c(31) = 0
c†(3-1) c(31)     -c†(1-1) c(31) + c†(3-1) c(11) + c†(3-1) c(51) - c†(5-1) c(31) = 0
c†(31) c(3-1)     -c†(11) c(3-1) + c†(31) c(1-1) + c†(31) c(5-1) - c†(51) c(3-1) = 0
c†(3-1) c(3-1)     -c†(1-1) c(3-1) + c†(3-1) c(1-1) + c†(3-1) c(5-1) - c†(5-1) c(3-1) = 0
c†(21) c(21)     -c†(11) c(21) + c†(21) c(11) + c†(21) c(41) - c†(41) c(21) = 0
c†(2-1) c(21)     -c†(1-1) c(21) + c†(2-1) c(11) + c†(2-1) c(41) - c†(4-1) c(21) = 0
c†(21) c(2-1)     -c†(11) c(2-1) + c†(21) c(1-1) + c†(21) c(4-1) - c†(41) c(2-1) = 0
c†(2-1) c(2-1)     -c†(1-1) c(2-1) + c†(2-1) c(1-1) + c†(2-1) c(4-1) - c†(4-1) c(2-1) = 0
c(11)     c(21) + c(31) - 4 c†(1-1) c(1-1) c(11) = 0
c†(11) c(11)     c†(11) c(21) + c†(11) c(31) - c†(21) c(11) - c†(31) c(11) = 0
c†(1-1) c(11)     c†(1-1) c(21) + c†(1-1) c(31) - c†(2-1) c(11) - c†(3-1) c(11) = 0
c†(1-1) c†(11) c(11)     4 c†(1-1) c†(11) c(11) + c†(1-1) c†(11) c(21) + c†(1-1) c†(11) c(31) - c†(1-1) c†(21) c(11) - c†(1-1) c†(31) c(11) + c†(11) c†(2-1) c(11) + c†(11) c†(3-1) c(11) = 0
c(1-1)     c(2-1) + c(3-1) + 4 c†(11) c(1-1) c(11) = 0
c†(11) c(1-1)     c†(11) c(2-1) + c†(11) c(3-1) - c†(21) c(1-1) - c†(31) c(1-1) = 0
c†(1-1) c(1-1)     c†(1-1) c(2-1) + c†(1-1) c(3-1) - c†(2-1) c(1-1) - c†(3-1) c(1-1) = 0
c†(1-1) c†(11) c(1-1)     4 c†(1-1) c†(11) c(1-1) + c†(1-1) c†(11) c(2-1) + c†(1-1) c†(11) c(3-1) - c†(1-1) c†(21) c(1-1) - c†(1-1) c†(31) c(1-1) + c†(11) c†(2-1) c(1-1) + c†(11) c†(3-1) c(1-1) = 0
c(1-1) c(11)     -4 c(1-1) c(11) + c(1-1) c(21) + c(1-1) c(31) - c(11) c(2-1) - c(11) c(3-1) = 0
c†(11) c(1-1) c(11)     -4 c†(11) c(1-1) c(11) + c†(11) c(1-1) c(21) + c†(11) c(1-1) c(31) - c†(11) c(11) c(2-1) - c†(11) c(11) c(3-1) - c†(21) c(1-1) c(11) - c†(31) c(1-1) c(11) = 0
c†(1-1) c(1-1) c(11)     -4 c†(1-1) c(1-1) c(11) + c†(1-1) c(1-1) c(21) + c†(1-1) c(1-1) c(31) - c†(1-1) c(11) c(2-1) - c†(1-1) c(11) c(3-1) - c†(2-1) c(1-1) c(11) - c†(3-1) c(1-1) c(11) = 0
c†(1-1) c†(11) c(1-1) c(11)     c†(1-1) c†(11) c(1-1) c(21) + c†(1-1) c†(11) c(1-1) c(31) - c†(1-1) c†(11) c(11) c(2-1) - c†(1-1) c†(11) c(11) c(3-1) - c†(1-1) c†(21) c(1-1) c(11) - c†(1-1) c†(31) c(1-1) c(11) + c†(11) c†(2-1) c(1-1) c(11) + c†(11) c†(3-1) c(1-1) c(11) = 0
```

可能出问题的地方包括
- 离谱的bug导致约束计算错误
- 老问题：虚部实部分离时乘法出错
- 太多变量没有出现在约束条件中？

观察是否各个约束都计算正确。以
```
c†(1-1) c†(11) c(1-1) c(11)  =>  c†(1-1) c†(11) c(1-1) c(21) + c†(1-1) c†(11) c(1-1) c(31) - c†(1-1) c†(11) c(11) c(2-1) - c†(1-1) c†(11) c(11) c(3-1) - c†(1-1) c†(21) c(1-1) c(11) - c†(1-1) c†(31) c(1-1) c(11) + c†(11) c†(2-1) c(1-1) c(11) + c†(11) c†(3-1) c(1-1) c(11) = 0
```
为例，在`2022-5-4.nb`中我们有
```
hubbardOpString[{SuperDagger[c], 1, "down"}, {SuperDagger[c], 1, "up"}, {c, 1, "down"}, {c, 2, "up"}] + 
 hubbardOpString[{SuperDagger[c], 1, "down"}, {SuperDagger[c], 1, "up"}, {c, 1, "down"}, {c, 3, "up"}] - 
 hubbardOpString[{SuperDagger[c], 1, "down"}, {SuperDagger[c], 1, "up"}, {c, 1, "up"}, {c, 2, "down"}] - 
 hubbardOpString[{SuperDagger[c], 1, "down"}, {SuperDagger[c], 1, "up"}, {c, 1, "up"}, {c, 3, "down"}] - 
 hubbardOpString[{SuperDagger[c], 1, "down"}, {SuperDagger[c], 2, "up"}, {c, 1, "down"}, {c, 1, "up"}] - 
 hubbardOpString[{SuperDagger[c], 1, "down"}, {SuperDagger[c], 3, "up"}, {c, 1, "down"}, {c, 1, "up"}] + 
 hubbardOpString[{SuperDagger[c], 1, "up"}, {SuperDagger[c], 2, "down"}, {c, 1, "down"}, {c, 1, "up"}] + 
 hubbardOpString[{SuperDagger[c], 1, "up"}, {SuperDagger[c], 3, "down"}, {c, 1, "down"}, {c, 1, "up"}]
```

| | |
| :------ | :------|
| `c†(1-1) c†(11) c(1-1) c(21)` | `hubbardOpString[{SuperDagger[c], 1, "down"}, {SuperDagger[c], 1, "up"}, {c, 1, "down"}, {c, 2, "up"}]`|
| ` c†(1-1) c†(11) c(1-1) c(31)` | `hubbardOpString[{SuperDagger[c], 1, "down"}, {SuperDagger[c], 1, "up"}, {c, 1, "down"}, {c, 3, "up"}]` |
| `- c†(1-1) c†(11) c(11) c(2-1)` | `-hubbardOpString[{SuperDagger[c], 1, "down"}, {SuperDagger[c], 1, "up"}, {c, 1, "up"}, {c, 2, "down"}]` |
| `- c†(1-1) c†(11) c(11) c(3-1)` | `- hubbardOpString[{SuperDagger[c], 1, "down"}, {SuperDagger[c], 1, "up"}, {c, 1, "up"}, {c, 3, "down"}]` |
| `- c†(1-1) c†(21) c(1-1) c(11)` | `- hubbardOpString[{SuperDagger[c], 1, "down"}, {SuperDagger[c], 2, "up"}, {c, 1, "down"}, {c, 1, "up"}]` |
| `- c†(1-1) c†(31) c(1-1) c(11)` | `- hubbardOpString[{SuperDagger[c], 1, "down"}, {SuperDagger[c], 3, "up"}, {c, 1, "down"}, {c, 1, "up"}]` |
| `c†(11) c†(2-1) c(1-1) c(11)` | `hubbardOpString[{SuperDagger[c], 1, "up"}, {SuperDagger[c], 2, "down"}, {c, 1, "down"}, {c, 1, "up"}]` |
| `c†(11) c†(3-1) c(1-1) c(11)` | `hubbardOpString[{SuperDagger[c], 1, "up"}, {SuperDagger[c], 3, "down"}, {c, 1, "down"}, {c, 1, "up"}]` |

应该是没问题了。

至少现在有一个问题，就是$K=5$时能够跑起来而$K=4$不行，说明$K=4$时，满足$l(O) \leq K / 2$的算符选两个乘起来可能会突破算符空间。这个是很奇怪的。

现在可以做的事情：
- 添加对称性的功能

关于粒子数算符和自旋算符的$\lang N, O \rang = 0$和$\lang S^z, O \rang = 0$约束，打印出来看一看：
```julia
N = sum(i -> cdag(i, 1) * c(i, 1) + cdag(i, -1) * c(i, -1), site_list) |> normal_form
Sz = sum(i -> cdag(i, 1) * c(i, 1) - cdag(i, -1) * c(i, -1), site_list) |> normal_form

for op in hubbard_opstr_basis
    println(comm(N, op) |> normal_form)
end

for op in hubbard_opstr_basis
    println(comm(Sz, op) |> normal_form)
end
```
发现输出从来不会多于一项——正确。

如下代码
```julia
count = 0
for op in hubbard_opstr_basis
    res = comm(N, op) |> normal_form
    if length(res.terms) == 0
        count += 1
    end
end
println(count)
```
给出110，`hubbard_opstr_basis`总共388个，然后`particle_number_constraint_ops`长度为278。一致。

我有点被整糊涂了，比如说site 2湮灭，然后site 1产生，这样的算符期望值是零吗？？？

DMRG的程序是容易写的，但是计算出来的能量和韩希之那篇Hubbard模型的文章中列举的参考数据不相符。在$t = 1, U = 4$时，我得到的单个site的能量是-0.81左右，但是韩希之的文章说是-0.58左右。
我猜测这是因为没有让总电子数保持为每个site分配一个电子的原因，把图画出来，是`2022-5-4.png`，可以看到明显每个site没有一个电子。
是否这是能量总体偏低的原因呢？

看来是的，需要加入能量守恒的条件。这么做了以后，我们得到`-56.999029759703596`的总能量，分到每个site上差不多-0.57，正好对上。

运行
```julia
plot(expect(ψ,"Nupdn"), legend = false)
```
得到`2022-5-4-2.png`。这和韩希之那篇文章上的结果也是一致的。

观察
```julia
 plot(correlation_matrix(ψ, "Cdagup", "Cup")[1, 1:20], legend = false)
```
会发现$c^\dag_i c_j$在$i \neq j$时也是可以有非零值的。

我们有
```
julia> expect(ψ, "Cdn")
100-element Array{Float64,1}:
 0.0
 0.0
 0.0
 0.0
 0.0
 ⋮
 0.0
 0.0
 0.0
 0.0
 0.0
```
因此看起来单独一个$c$算符的期望值确实是零。

```
julia> correlation_matrix(ψ, "Cdagdn", "Cdagdn")
100×100 Array{Float64,2}:
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     
 ⋮                        ⋮                        ⋱  ⋮                        ⋮
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  
```
因此两个$c$乘积的期望值确实是零。

在`dmrg.jl`中频繁地出现一些错误：
- `ERROR: Parity-odd fermionic terms not yet supported by AutoMPO`
- `ERROR: No block found with QN equal to QN(("Nf",-2,-1),("Sz",0))`

```julia
opstr_mpo = OpSum()
opstr_mpo += "Cdagup", 50, "Cdagdn", 50, "Cdn", 50
inner(ψ, MPO(opstr_mpo, sites), ψ)
```
确实给出`ERROR: Parity-odd fermionic terms not yet supported by AutoMPO`。

```julia
opstr_mpo = OpSum()
opstr_mpo += "Cdagup", 50, "Cdagdn", 50, "Cdagdn", 50, "Cup", 49
inner(ψ, MPO(opstr_mpo, sites), ψ)
```
给出`No block found with QN equal to QN(("Nf",-2,-1),("Sz",2))`，虽然它显然是零！

```julia
opstr_mpo = OpSum()
opstr_mpo += "Cdagup", 50, "Cdagdn", 50, "Cdn", 50, "Cup", 49
inner(ψ, MPO(opstr_mpo, sites), ψ)
```
就不报错。

```julia
for op in particle_number_constraint_ops
    println(benchmark_point_dmrg[op])
end

##

for op in spin_constraint_ops
    println(benchmark_point_dmrg[op])
end
```
输出的结果全都是零，因此这些约束是正确的。

通过DMRG获得的期望值都是实数；在构造优化问题时，我们可以不必分开虚部和实部，直接上手做。原本区分虚部实部的代码放在`optimization_problem-original.jl`中，我们去处理`optimization_problem.jl`。

报奇怪的错，什么variable not owned之类的。

我们索性一次把benchmark做完吧。

```julia
(
    - t * benchmark_point_dmrg[cdag(1,-1) * c(2,-1)] 
    - t * benchmark_point_dmrg[cdag(1, -1) * c(3, -1)] 
    - t * benchmark_point_dmrg[cdag(1, 1) * c(2, 1)] 
    - t * benchmark_point_dmrg[cdag(1, 1) * c(3, 1)] 
    - U * benchmark_point_dmrg[cdag(1, -1) * cdag(1, 1) * c(1, -1) * c(1, 1)]
)
```
给出`-0.5736684912615906`，这个是正确的。

运行
```julia
hubbard_opstr_basis_expected_dmrg_values = map(hubbard_opstr_basis) do op
    benchmark_point_dmrg[op]
end

for constraint_coefficients in H_constraints_coefficients
    println(constraint_coefficients' * hubbard_opstr_basis_expected_dmrg_values)
end
```
得到
```
0.0     
0.0
0.0
0.0
-2.7755575615628914e-17
0.0
0.0
-4.718447854656915e-16
3.0531133177191805e-16
0.0
0.0
-4.996003610813204e-16
0.0
-3.608224830031759e-16
0.0
0.0
0.0
0.0
7.216449660063518e-16
0.0
0.0
0.0
0.0
```
因此最大的violation多半是数值舍入误差。

运行
```julia
M_dmrg = zeros(length(M_mat_spanning_opstr_indices), length(M_mat_spanning_opstr_indices))

for i in 1 : length(M_mat_spanning_opstr_indices)
    for j in 1 : length(M_mat_spanning_opstr_indices)
        M_dmrg[i, j] = M_coefficient[i, j]' * hubbard_opstr_basis_expected_dmrg_values
    end
end

eigen(M_dmrg).values
```
发现本征值好像都是正的。

这样benchmark应该是没问题的；但是，运行结果仍然是`Status: Dual_infeasible`。

换了一下SCS也说不feasible。

# 2022.5.5

至少存在两个问题。
- 首先是`⟨1⟩`是1这个事实好像从来没有被体现出来过，可能这个是SCS之前提示unbounded的一个原因
- 其次是存在`0 == 0.0`这样的空约束

第二个问题似乎是因为某些约束是只关于那些由于对称性，期望值就是零的算符的。例如：
```
julia> H_constraints_coefficients[2]' * hubbard_opstr_basis_expected
0
```

在解决了第一个问题之后，我们第一次成功地完成了优化：
```
------------------------------------------------------------------
          COSMO v0.8.5 - A Quadratic Objective Conic Solver       
                         Michael Garstka
                University of Oxford, 2017 - 2022
------------------------------------------------------------------

Problem:  x ∈ R^{249},
          constraints: A ∈ R^{574x249} (635 nnz),
          matrix size to factor: 823x823,
          Floating-point precision: Float64
Sets:     ZeroSe of dim: 384
          DensePsdConeTriangl of dim: 190 (19x19)
Settings: ϵ_abs = 1.0e-05, ϵ_rel = 1.0e-05,
          ϵ_prim_inf = 1.0e-04, ϵ_dual_inf = 1.0e-04,
          ρ = 0.1, σ = 1e-06, α = 1.6,
          max_iter = 10000,
          scaling iter = 10 (on),
          check termination every 25 iter,
          check infeasibility every 40 iter,
          KKT system solver: QDLDL
Acc:      Anderson Type2{QRDecomp},
          Memory size = 15, RestartedMemory,
          Safeguarded: true, tol: 2.0
Setup Time: 22.12ms

Iter:   Objective:      Primal Res:     Dual Res:       Rho:
1       -9.1610e+01     1.7436e+01      2.4000e+00      1.0000e-01
25      -1.5198e+00     4.0724e-01      3.3926e-03      1.0000e-01
50      -1.5112e+00     3.9729e-02      4.3331e-02      1.4659e+00
75      -1.4139e+00     5.8403e-04      1.6583e-03      1.4659e+00
100     -1.4142e+00     3.4482e-09      3.5617e-07      1.4659e+00

------------------------------------------------------------------
>>> Results
Status: Solved
Iterations: 140 (incl. 40 safeguarding iter)
Optimal objective: -1.414
Runtime: 0.117s (117.0ms)
```
能量非常不理想，但是输出结果`2022-5-3-run-1`中，$S^z_i$是正确的。（$n_i$怎么算正确我不知道）

$K=6$还是遇到了某个地方$M$矩阵中涉及的算符多于算符空间这一诡异现象。$K=7$时能量为
```
Iter:   Objective:      Primal Res:     Dual Res:       Rho:
1       -3.0573e+01     6.7786e+00      2.4000e+00      1.0000e-01
25      -1.1683e+00     3.1424e-02      4.3395e-03      1.0000e-01
50      -1.1081e+00     3.8381e-03      2.0490e-04      1.0000e-01
75      -1.1019e+00     8.8231e-04      1.8142e-04      1.0000e-01
100     -1.1028e+00     4.1745e-05      2.6707e-06      1.0000e-01
125     -1.1028e+00     3.2389e-06      3.8150e-07      9.4809e-01

------------------------------------------------------------------
>>> Results
Status: Solved
Iterations: 130 (incl. 5 safeguarding iter)
Optimal objective: -1.103
Runtime: 1.049s (1049.0ms)
```

拿到服务器上算，已知$K=11$时会因为内存不够被杀掉。

$K=9$时能量为
```
725 -9.7588e-01 2.0974e-05  7.9858e-05  1.8833e+00
750 -9.7587e-01 2.0464e-05  1.2046e-04  1.8833e+00
775 -9.7588e-01 1.9767e-05  2.3698e-05  1.8833e+00

------------------------------------------------------------------
>>> Results
Status: Solved
Iterations: 775
Optimal objective: -0.9759
Runtime: 19.874s (19873.69ms)
```


尝试引入平移约束，之前写的代码
```julia
translational_clusters = Vector{Int}[]

let remaining_ops_indices = collect(2 : hubbard_opstr_basis_length) 
    while ! isempty(remaining_ops_indices)
        current_op = remaining_ops_indices[1]
        translational_indices = Int[]
        for Δx in - 2K : 2K
            translated_op = hubbard_opstr_translate(hubbard_opstr_basis[current_op], Δx)
            
            if translated_op === nothing
                continue
            end

            translated_op_idx = findfirst(x -> x == translated_op, hubbard_opstr_basis)
            if translated_op_idx !== nothing
                push!(translational_indices, translated_op_idx)
            end
        end
        sort!(translational_indices)
        push!(translational_clusters, translational_indices)
        filter!(x -> x ∉ translational_indices, remaining_ops_indices)
    end
end
```
并不好用，因为这会导致`c(41) c(31)`这样，排在前面的算符的格点编号大于排在后面的算符，从而不在基底中，但是的确可以用对称性划归到另一个算符中的算符没有被划归。

看起来，还是应该拿平移变换的生成元来做。

加入对称性约束以后，$K=9$的能量能够计算到`-0.754`。

现在我们来排除更加咬口的偶数$K$无法正确处理的问题。以$K=4$为例，此时
```
julia> qualified_opstr_site_configuration
20-element Array{Array{Symbol,1},1}:
 [:no, :no, :no, :no, :no, :no, :no, :no, :no]
 [:no, :no, :no, :no, :up, :no, :no, :no, :no]
 [:no, :no, :no, :no, :dn, :no, :no, :no, :no]
 [:no, :no, :no, :up, :no, :no, :no, :no, :no]
 [:no, :no, :no, :dn, :no, :no, :no, :no, :no]
 [:no, :no, :up, :no, :no, :no, :no, :no, :no]
 [:no, :no, :dn, :no, :no, :no, :no, :no, :no]
 [:no, :up, :no, :no, :no, :no, :no, :no, :no]
 [:no, :dn, :no, :no, :no, :no, :no, :no, :no]
 [:up, :no, :no, :no, :no, :no, :no, :no, :no]
 [:up, :no, :up, :no, :no, :no, :no, :no, :no]
 [:up, :no, :dn, :no, :no, :no, :no, :no, :no]
 [:up, :up, :no, :no, :no, :no, :no, :no, :no]
 [:up, :dn, :no, :no, :no, :no, :no, :no, :no]
 [:dn, :no, :no, :no, :no, :no, :no, :no, :no]
 [:dn, :no, :up, :no, :no, :no, :no, :no, :no]
 [:dn, :no, :dn, :no, :no, :no, :no, :no, :no]
 [:dn, :up, :no, :no, :no, :no, :no, :no, :no]
 [:dn, :dn, :no, :no, :no, :no, :no, :no, :no]
 [:both, :no, :no, :no, :no, :no, :no, :no, :no]
```
并且
```
julia> cdag(2,1) * cdag(3,1) in hubbard_opstr_basis
false
```
可以看到，
```
[:no, :up, :no, :no, :no, :no, :no, :no, :no]
```
后面没有出现
```
[:no, :up, :up, :no, :no, :no, :no, :no, :no]
```

看起来似乎是“什么都没有”的算符长度被算成了1而不是零。排除此错误，发现$K=2n$和$K=2n+1$行为类似。
目前最好的结果仍然是`-0.754`。$K=6$时是`-0.8327`。

为了看$K=10$时情况如何，增大内存限制。

# 2022.5.6

$K=10$时开12个cpu，指望着系统按照cpu数目分配内存是不行的：照样会被杀掉。

先取$K=8$，绝对不会有内存不够的现象：

- slurm id为1466613：12个cpu，指望着系统按照cpu数目分配内存

没有出问题，然后$K=10$就会出问题。hmm……要么是内存即使是12 * 4 = 48G还是不够，要么就是不是按照核心数目分配内存的。

我们来估算一下$K=10$时需要多少内存资源，以及到底是哪里溢出了。检查输出文件，会发现operator labels能够正确构造。
然而，在运行到输出
```
hubbard_opstr_basis[27298]  =  c(1-1) c(11) c(2-1) c(21) c(3-1) c(31)
```
时，程序因为内存容量不足被杀掉了。

这个log来自`operator-algebra.jl`的
```julia
 println(file, "hubbard_opstr_basis[$i]  =  ", opstr)
```
一行。看起来，这似乎是说明了在程序被杀掉时，列举`hubbard_opstr_basis`的工作是已经完成了。

这么说，内存问题是在构造M矩阵时出现的？

为此，引入如下代码：
```julia
open(working_path * output_name, "a") do file
    println(file, "Start to build M matrix.")
end
```

计算在
```
Spanning operators chosen. Total number = 476
```
这句log处中止。

现在想一想，出现内存溢出也是正确的，因为此时，为了保存`M_coefficient`需要`476^2 * 27298 = 6185071648`个`Float64`。
我觉得我可能需要稀疏矩阵。

在改用稀疏矩阵后，能够运行到构建优化问题的这一步。

之后声明变量这一步就要差不多五分钟……

# 2022.5.7

昨天跑出来的能量是`-0.65`，这个是$K=10$的结果。即使这么大的问题，优化起来也非常容易！

扩展到$K=12$。此时`max_qualified_opstr_num`和`max_search_num`的限制必须增大了。增大以后，在`Start to build M matrix.`和`Spanning operators chosen.`之间发现了一个内存溢出错误。
我有点怀疑是`hubbard_opstr_normal_order`导致的，尤其是考虑到它声明以后从来没用到过。

# 2022.5.8

$K=12$的结果（slurm id 1507651）是-0.6475左右；看起来离我想要的结果仍然差了蛮远的；即使涉及到的算符数目已经到了70万个，主要的计算瓶颈仍然不在求解器上。

我有点怀疑是不是要在这里也弄一个粒子总数的约束。尝试在`optimization_problem.jl`中施加这个约束：

感觉要完蛋，为什么优化出来的结果是
```
Optimization results:

Objective value:   -0.5577179018826584

-----------------------------------------------------------

Expected ⟨n_i↑ n_i↓⟩:  0.18313117576543192
```

果然，药丸的东西还是来了。$K = 10$时单个格点上的能量有$-0.01$那么多，很明显错了。

需要DMRG校对一下了。为了确认是否整个程序都没问题，直接通过feasibility test来做这件事。在`dmrg.jl`中完成了这件事。

现在需要做的事情：
- 粗粗扫了一眼，我感觉好像和平移对称性有关的约束被违反得格外厉害
- 需要考虑总电子数要如何加入约束中

取$K = 6$，我们有
```julia
for i in 1 : length(site_list)
    if ! (cdag(i, ↑) * c(i, ↑) in hubbard_opstr_basis)
        break
    end
    println((cdag(i, ↑) * c(i, ↑) + cdag(i, ↓) * c(i, ↓)) |> dmrg_value)
end
```
给出
```
1.0000000000440628
1.0000000000128377
0.9999999997891915
1.0000000000564344
1.0000000002891811
```
因此DMRG保证每个格点上一个电子，这个约束是没有问题的。

下面检查infeasibility report。
```
-2 ⟨c†(3-1) c†(31) c(1-1) c(11)⟩ - ⟨c†(21) c†(3-1) c(1-1) c(11)⟩ + ⟨c†(2-1) c†(31) c(1-1) c(11)⟩ == 0.0 => 
0.0012302276680474927
⟨c†(31) c(51)⟩ - ⟨c†(11) c(31)⟩ == 0.0 => 0.011800052653368587
-⟨c†(1-1) c†(11) c(1-1) c(31)⟩ + ⟨c†(1-1) c†(11) c(1-1) c(21)⟩ == 0.0 => 0.005914836722201444
-⟨c†(51) c(31)⟩ + ⟨c†(41) c(21)⟩ == 0.0 => 0.011810735105781262
-⟨c†(1-1) c†(2-1) c(1-1) c(3-1)⟩ + ⟨c†(1-1) c†(3-1) c(1-1) c(2-1)⟩ == 0.0 => 1.3877787807814457e-17        
⟨c†(3-1) c(3-1)⟩ - ⟨c†(1-1) c(1-1)⟩ == 0.0 => 0.14727195190845083
-⟨c†(11) c(51)⟩ + ⟨c†(11) c(41)⟩ == 0.0 => 0.00014474347760085396
-⟨c†(5-1) c(4-1)⟩ + ⟨c†(7-1) c(2-1)⟩ == 0.0 => 0.017595791975393106
⟨c†(1-1) c†(31) c(1-1) c(11)⟩ - ⟨c†(1-1) c†(21) c(1-1) c(11)⟩ == 0.0 => 0.0059148367222016385
⟨c†(6-1) c(3-1)⟩ - ⟨c†(7-1) c(2-1)⟩ == 0.0 => 8.381835552363076e-5
⟨c†(41) c(31)⟩ - ⟨c†(51) c(21)⟩ == 0.0 => 0.006005232151201724
⟨c†(71) c(11)⟩ - ⟨c†(61) c(11)⟩ == 0.0 => 0.006027154046252703
-⟨c†(3-1) c(2-1)⟩ + ⟨c†(5-1) c(1-1)⟩ == 0.0 => 0.03943147446714
⟨c†(11) c†(21) c(11) c(31)⟩ - ⟨c†(11) c†(31) c(11) c(21)⟩ == 0.0 => 8.326672684688674e-17
-⟨c†(2-1) c(7-1)⟩ + ⟨c†(3-1) c(6-1)⟩ == 0.0 => 8.381835552362035e-5
⟨c†(2-1) c(5-1)⟩ - ⟨c†(4-1) c(3-1)⟩ == 0.0 => 0.006005232153568865
⟨c†(11) c(31)⟩ - ⟨c†(11) c(21)⟩ == 0.0 => 0.011788246976749156
⟨c†(71) c(31)⟩ - ⟨c†(51) c(11)⟩ == 0.0 => 0.03955875844578462
-⟨c†(3-1) c(3-1)⟩ + ⟨c†(2-1) c(2-1)⟩ == 0.0 => 0.00022547495363289816
⟨c†(1-1) c†(31) c(11) c(2-1)⟩ - ⟨c†(1-1) c†(31) c(1-1) c(21)⟩ + ⟨c†(3-1) c†(31) c(1-1) c(11)⟩ + ⟨c†(1-1) c†(51) c(1-1) c(11)⟩ == 0.0 => 0.006325288666307938
-⟨c†(1-1) c†(11) c(11) c(5-1)⟩ + ⟨c†(1-1) c†(11) c(11) c(4-1)⟩ == 0.0 => 0.0013712503772189454
⟨c†(3-1) c(3-1)⟩ - ⟨c†(2-1) c(2-1)⟩ == 0.0 => 0.00022547495363289816
-⟨c†(41) c(21)⟩ + ⟨c†(21) c(11)⟩ == 0.0 => 0.011798929429162386
⟨c†(21) c(41)⟩ - ⟨c†(41) c(21)⟩ - ⟨c†(11) c(21)⟩ + ⟨c†(21) c(11)⟩ == 0.0 => 3.0531133177191805e-16
⟨c†(11) c†(3-1) c(11) c(3-1)⟩ - ⟨c†(11) c†(2-1) c(11) c(2-1)⟩ == 0.0 => 0.007761219933729024
⟨c†(3-1) c(5-1)⟩ - ⟨c†(1-1) c(3-1)⟩ == 0.0 => 0.011800052496783703
-⟨c†(21) c(61)⟩ + ⟨c†(11) c(41)⟩ == 0.0 => 0.03942840987269802
-⟨c†(31) c(41)⟩ + ⟨c†(51) c(21)⟩ == 0.0 => 0.00600523215120162
-⟨c†(7-1) c(3-1)⟩ + ⟨c†(6-1) c(2-1)⟩ == 0.0 => 0.0002750920064647916
-⟨c†(31) c(51)⟩ + ⟨c†(21) c(41)⟩ == 0.0 => 0.011810735105782122
⟨c†(2-1) c(3-1)⟩ - ⟨c†(3-1) c(2-1)⟩ == 0.0 => 7.28583859910259e-17
⟨c†(1-1) c†(11) c(11) c(5-1)⟩ - ⟨c†(1-1) c†(11) c(11) c(4-1)⟩ == 0.0 => 0.0013712503772189454
⟨c†(1-1) c(7-1)⟩ - ⟨c†(1-1) c(6-1)⟩ == 0.0 => 0.006027154150668068
⟨c†(11) c†(3-1) c(1-1) c(11)⟩ - ⟨c†(11) c†(2-1) c(1-1) c(11)⟩ == 0.0 => 0.00587341021734486
⟨c†(5-1) c(5-1)⟩ - ⟨c†(4-1) c(4-1)⟩ == 0.0 => 0.0005321625516380157
⟨c†(31) c(71)⟩ - ⟨c†(21) c(61)⟩ == 0.0 => 0.00027509205068757675
⟨c†(51) c(51)⟩ - ⟨c†(31) c(31)⟩ == 0.0 => 0.14696835148605436
⟨c†(41) c(31)⟩ - ⟨c†(61) c(11)⟩ == 0.0 => 0.00601537769191967
⟨c†(7-1) c(3-1)⟩ - ⟨c†(5-1) c(1-1)⟩ == 0.0 => 0.039558758299857166
⟨c†(1-1) c†(11) c(11) c(3-1)⟩ - ⟨c†(1-1) c†(11) c(11) c(2-1)⟩ == 0.0 => 0.005873410217345429
⟨c†(1-1) c(7-1)⟩ - ⟨c†(2-1) c(5-1)⟩ == 0.0 => 0.006017008777359202
⟨c†(11) c†(3-1) c(11) c(2-1)⟩ - ⟨c†(11) c†(3-1) c(1-1) c(21)⟩ - ⟨c†(3-1) c†(31) c(1-1) c(11)⟩ + ⟨c†(11) c†(5-1) c(1-1) c(11)⟩ == 0.0 => 0.033106185774793344
⟨c†(71) c(31)⟩ - ⟨c†(61) c(21)⟩ == 0.0 => 0.00027509205068746573
⟨c†(1-1) c†(51) c(1-1) c(11)⟩ - ⟨c†(1-1) c†(41) c(1-1) c(11)⟩ == 0.0 => 0.0015159937473414181
-⟨c†(1-1) c†(11) c(21) c(3-1)⟩ - ⟨c†(11) c†(3-1) c(11) c(3-1)⟩ + ⟨c†(1-1) c†(31) c(11) c(3-1)⟩ + ⟨c†(1-1) c†(11) c(1-1) c(11)⟩ == 0.0 => 0.3427316563091772
⟨c†(1-1) c†(11) c(1-1) c(31)⟩ - ⟨c†(1-1) c†(11) c(1-1) c(21)⟩ == 0.0 => 0.005914836722201444
-⟨c†(7-1) c(1-1)⟩ + ⟨c†(6-1) c(1-1)⟩ == 0.0 => 0.006027154150667895
⟨c†(11) c(71)⟩ - ⟨c†(11) c(61)⟩ == 0.0 => 0.006027154046252696
-⟨c†(51) c(51)⟩ + ⟨c†(41) c(41)⟩ == 0.0 => 0.0005321627843847265
⟨c†(2-1) c(3-1)⟩ - ⟨c†(4-1) c(1-1)⟩ == 0.0 => 0.039576218022810195
-⟨c†(61) c(21)⟩ + ⟨c†(41) c(11)⟩ == 0.0 => 0.03942840987269793
-⟨c†(1-1) c†(11) c(11) c(3-1)⟩ + ⟨c†(1-1) c†(11) c(11) c(2-1)⟩ == 0.0 => 0.005873410217345429
-⟨c†(71) c(11)⟩ + ⟨c†(61) c(11)⟩ == 0.0 => 0.006027154046252703
-⟨c†(11) c(91)⟩ + ⟨c†(11) c(81)⟩ == 0.0 => 0.00017455313240888858
⟨c†(21) c(71)⟩ - ⟨c†(31) c(61)⟩ == 0.0 => 8.381839568536581e-5
-⟨c†(1-1) c†(11) c(3-1) c(31)⟩ + 2 ⟨c†(1-1) c†(11) c(2-1) c(31)⟩ - ⟨c†(1-1) c†(11) c(2-1) c(21)⟩ == 0.0 => 
0.003990630813205387
-⟨c†(2-1) c(4-1)⟩ + ⟨c†(1-1) c(2-1)⟩ == 0.0 => 0.01179892933622928
-⟨c†(51) c(11)⟩ + ⟨c†(41) c(11)⟩ == 0.0 => 0.00014474347760077763
-⟨c†(11) c†(2-1) c(1-1) c(31)⟩ + ⟨c†(11) c†(3-1) c(1-1) c(21)⟩ == 0.0 => 1.2359517576054913e-10
⟨c†(1-1) c†(11) c(3-1) c(31)⟩ + 2 ⟨c†(1-1) c†(11) c(21) c(3-1)⟩ + ⟨c†(1-1) c†(11) c(2-1) c(21)⟩ == 0.0 => 0.003990630717709123
-⟨c†(6-1) c(3-1)⟩ + ⟨c†(7-1) c(2-1)⟩ == 0.0 => 8.381835552363076e-5
-⟨c†(11) c(41)⟩ + ⟨c†(31) c(21)⟩ == 0.0 => 0.03957621794293681
⟨c†(11) c†(2-1) c(1-1) c(31)⟩ - ⟨c†(11) c†(3-1) c(1-1) c(21)⟩ == 0.0 => 1.2359517576054913e-10
-⟨c†(1-1) c†(31) c(1-1) c(11)⟩ + ⟨c†(1-1) c†(21) c(1-1) c(11)⟩ == 0.0 => 0.0059148367222016385
⟨c†(51) c(31)⟩ - ⟨c†(31) c(11)⟩ == 0.0 => 0.011800052653368559
-⟨c†(71) c(21)⟩ + ⟨c†(91) c(11)⟩ == 0.0 => 0.017503077856526356
⟨c†(11) c†(5-1) c(1-1) c(11)⟩ - ⟨c†(11) c†(4-1) c(1-1) c(11)⟩ == 0.0 => 0.0013712503772189293
-⟨c†(11) c(81)⟩ + ⟨c†(31) c(61)⟩ == 0.0 => 0.01759381259324993
⟨c†(31) c(51)⟩ - ⟨c†(21) c(41)⟩ == 0.0 => 0.011810735105782122
-⟨c†(1-1) c(3-1)⟩ + ⟨c†(1-1) c(2-1)⟩ == 0.0 => 0.011788246737419433
⟨c†(11) c(11)⟩ + ⟨c†(1-1) c(1-1)⟩ + ⟨c†(1-1) c†(11) c(1-1) c(11)⟩ + M[20,20] == 1.0 => 1.1102230246251565e-16
⟨c†(1-1) c†(31) c(1-1) c(31)⟩ - ⟨c†(1-1) c†(21) c(1-1) c(21)⟩ == 0.0 => 0.007986694736105193
⟨c†(11) c†(3-1) c(1-1) c(31)⟩ - ⟨c†(11) c†(2-1) c(1-1) c(21)⟩ == 0.0 => 0.018455024693114913
⟨c†(21) c(51)⟩ - ⟨c†(31) c(41)⟩ == 0.0 => 0.006005232151201655
-⟨c†(21) c†(3-1) c(1-1) c(11)⟩ + ⟨c†(2-1) c†(31) c(1-1) c(11)⟩ - 2 ⟨c†(2-1) c†(21) c(1-1) c(11)⟩ == 0.0 => 
0.006751033862867489
⟨c†(11) c(51)⟩ - ⟨c†(21) c(31)⟩ == 0.0 => 0.03943147446533593
-⟨c†(1-1) c†(11) c(11) c(3-1)⟩ - ⟨c†(1-1) c†(11) c(11) c(2-1)⟩ + ⟨c†(1-1) c†(11) c(1-1) c(31)⟩ + ⟨c†(1-1) c†(11) c(1-1) c(21)⟩ + ⟨c†(11) c†(3-1) c(1-1) c(11)⟩ + ⟨c†(11) c†(2-1) c(1-1) c(11)⟩ - ⟨c†(1-1) c†(31) c(1-1) c(11)⟩ - ⟨c†(1-1) c†(21) c(1-1) c(11)⟩ == 0.0 => 9.71445146547012e-16
⟨c†(31) c(51)⟩ - ⟨c†(51) c(31)⟩ - ⟨c†(11) c(31)⟩ + ⟨c†(31) c(11)⟩ == 0.0 => 2.7755575615628914e-17
-⟨c†(11) c(71)⟩ + ⟨c†(11) c(61)⟩ == 0.0 => 0.006027154046252696
-⟨c†(5-1) c(1-1)⟩ + ⟨c†(4-1) c(1-1)⟩ == 0.0 => 0.00014474355567012376
⟨c†(31) c(71)⟩ - ⟨c†(11) c(51)⟩ == 0.0 => 0.03955875844578475
-⟨c†(21) c(41)⟩ + ⟨c†(11) c(21)⟩ == 0.0 => 0.011798929429162691
⟨c†(1-1) c†(31) c(11) c(3-1)⟩ - ⟨c†(1-1) c†(21) c(11) c(2-1)⟩ == 0.0 => 0.018455024693115135
-⟨c†(41) c(31)⟩ + ⟨c†(51) c(21)⟩ == 0.0 => 0.006005232151201724
-⟨c†(41) c(51)⟩ + ⟨c†(51) c(41)⟩ == 0.0 => 2.7755575615628914e-17
⟨c†(5-1) c(3-1)⟩ - ⟨c†(3-1) c(1-1)⟩ == 0.0 => 0.011800052496783231
-⟨c†(1-1) c(2-1)⟩ + ⟨c†(3-1) c(1-1)⟩ == 0.0 => 0.011788246737418906
⟨c†(3-1) c(7-1)⟩ - ⟨c†(1-1) c(5-1)⟩ == 0.0 => 0.039558758299857166
-⟨c†(1-1) c†(11) c(2-1) c(21)⟩ - ⟨c†(1-1) c†(11) c(1-1) c(41)⟩ - ⟨c†(11) c†(3-1) c(1-1) c(21)⟩ + ⟨c†(1-1) c†(31) c(1-1) c(21)⟩ == 0.0 => 0.005080879439834521
-⟨c†(6-1) c(2-1)⟩ + ⟨c†(4-1) c(1-1)⟩ == 0.0 => 0.0394284098490625
-⟨c†(21) c(21)⟩ + ⟨c†(11) c(11)⟩ == 0.0 => 0.1470464769235928
-⟨c†(41) c(41)⟩ + ⟨c†(21) c(21)⟩ == 0.0 => 0.1472750395404524
⟨c†(51) c(31)⟩ - ⟨c†(41) c(21)⟩ == 0.0 => 0.011810735105781262
⟨c†(51) c(11)⟩ - ⟨c†(41) c(11)⟩ == 0.0 => 0.00014474347760077763
-⟨c†(11) c†(3-1) c(11) c(3-1)⟩ + ⟨c†(11) c†(2-1) c(11) c(2-1)⟩ == 0.0 => 0.007761219933729024
2 ⟨c†(1-1) c†(11) c(3-1) c(31)⟩ + ⟨c†(1-1) c†(11) c(21) c(3-1)⟩ - ⟨c†(1-1) c†(11) c(2-1) c(31)⟩ == 0.0 => 0.0012302276680471666
⟨c†(31) c(31)⟩ - ⟨c†(21) c(21)⟩ == 0.0 => 0.0002254747299866855
⟨c†(3-1) c(1-1)⟩ - ⟨c†(2-1) c(1-1)⟩ == 0.0 => 0.0117882467374191
⟨c†(11) c(71)⟩ - ⟨c†(21) c(51)⟩ == 0.0 => 0.006017008505534854
⟨c†(9-1) c(1-1)⟩ - ⟨c†(8-1) c(1-1)⟩ == 0.0 => 0.00017455323236757747
-⟨c†(11) c†(21) c(11) c(31)⟩ + ⟨c†(11) c†(31) c(11) c(21)⟩ == 0.0 => 8.326672684688674e-17
⟨c†(2-1) c(7-1)⟩ - ⟨c†(3-1) c(6-1)⟩ == 0.0 => 8.381835552362035e-5
-⟨c†(9-1) c(1-1)⟩ + ⟨c†(8-1) c(1-1)⟩ == 0.0 => 0.00017455323236757747
-⟨c†(21) c(51)⟩ + ⟨c†(31) c(41)⟩ == 0.0 => 0.006005232151201655
-⟨c†(4-1) c(3-1)⟩ + ⟨c†(5-1) c(2-1)⟩ == 0.0 => 0.006005232153568851
⟨c†(5-1) c(1-1)⟩ - ⟨c†(4-1) c(1-1)⟩ == 0.0 => 0.00014474355567012376
-⟨c†(5-1) c(5-1)⟩ + ⟨c†(4-1) c(4-1)⟩ == 0.0 => 0.0005321625516380157
⟨c†(11) c†(2-1) c(11) c(3-1)⟩ - ⟨c†(11) c†(3-1) c(11) c(2-1)⟩ == 0.0 => 4.5102810375396984e-17
⟨c†(1-1) c(3-1)⟩ - ⟨c†(2-1) c(1-1)⟩ == 0.0 => 0.011788246737419628
⟨c†(1-1) c†(21) c(11) c(3-1)⟩ - ⟨c†(1-1) c†(31) c(11) c(2-1)⟩ == 0.0 => 1.235951271882918e-10
⟨c†(5-1) c(5-1)⟩ - ⟨c†(3-1) c(3-1)⟩ == 0.0 => 0.14696835198604402
⟨c†(11) c†(31) c(11) c(31)⟩ - ⟨c†(11) c†(21) c(11) c(21)⟩ == 0.0 => 0.010521623165352725
-⟨c†(1-1) c†(31) c(11) c(3-1)⟩ + ⟨c†(1-1) c†(21) c(11) c(2-1)⟩ == 0.0 => 0.018455024693115135
-⟨c†(2-1) c(5-1)⟩ + ⟨c†(3-1) c(4-1)⟩ == 0.0 => 0.006005232153568775
-⟨c†(4-1) c(5-1)⟩ + ⟨c†(5-1) c(4-1)⟩ == 0.0 => 1.0408340855860843e-17
⟨c†(1-1) c†(3-1) c(1-1) c(3-1)⟩ - ⟨c†(1-1) c†(2-1) c(1-1) c(2-1)⟩ == 0.0 => 0.010747097921700227
⟨c†(1-1) c(9-1)⟩ - ⟨c†(1-1) c(8-1)⟩ == 0.0 => 0.00017455323236759655
-⟨c†(1-1) c†(11) c(1-1) c(51)⟩ + ⟨c†(1-1) c†(11) c(1-1) c(41)⟩ == 0.0 => 0.0015159937473414875
⟨c†(1-1) c†(21) c(1-1) c(31)⟩ - ⟨c†(1-1) c†(31) c(1-1) c(21)⟩ == 0.0 => 7.37257477290143e-18
⟨c†(1-1) c†(11) c(11) c(2-1)⟩ - ⟨c†(1-1) c†(11) c(1-1) c(21)⟩ - ⟨c†(11) c†(3-1) c(1-1) c(11)⟩ + ⟨c†(1-1) c†(31) c(1-1) c(11)⟩ == 0.0 => 0.011788246939546193
⟨c†(61) c(31)⟩ - ⟨c†(71) c(21)⟩ == 0.0 => 8.381839568529989e-5
-⟨c†(11) c†(31) c(11) c(31)⟩ + ⟨c†(11) c†(21) c(11) c(21)⟩ == 0.0 => 0.010521623165352725
-⟨c†(11) c†(5-1) c(1-1) c(11)⟩ + ⟨c†(11) c†(4-1) c(1-1) c(11)⟩ == 0.0 => 0.0013712503772189293
-⟨c†(1-1) c(6-1)⟩ + ⟨c†(3-1) c(4-1)⟩ == 0.0 => 0.006015377526877641
-⟨c†(5-1) c(2-1)⟩ + ⟨c†(7-1) c(1-1)⟩ == 0.0 => 0.006017008777359119
-⟨c†(21) c(71)⟩ + ⟨c†(31) c(61)⟩ == 0.0 => 8.381839568536581e-5
-⟨c†(1-1) c(9-1)⟩ + ⟨c†(1-1) c(8-1)⟩ == 0.0 => 0.00017455323236759655
-⟨c†(11) c†(2-1) c(11) c(3-1)⟩ + ⟨c†(11) c†(3-1) c(11) c(2-1)⟩ == 0.0 => 4.5102810375396984e-17
-⟨c†(4-1) c(4-1)⟩ + ⟨c†(2-1) c(2-1)⟩ == 0.0 => 0.14727503958404914
-⟨c†(4-1) c(2-1)⟩ + ⟨c†(2-1) c(1-1)⟩ == 0.0 => 0.01179892933622978
⟨c†(7-1) c(3-1)⟩ - ⟨c†(6-1) c(2-1)⟩ == 0.0 => 0.0002750920064647916
-⟨c†(1-1) c†(3-1) c(1-1) c(3-1)⟩ + ⟨c†(1-1) c†(2-1) c(1-1) c(2-1)⟩ == 0.0 => 0.010747097921700227
-⟨c†(31) c(21)⟩ + ⟨c†(51) c(11)⟩ == 0.0 => 0.03943147446533596
⟨c†(1-1) c†(21) c(11) c(2-1)⟩ - ⟨c†(1-1) c†(21) c(1-1) c(21)⟩ - ⟨c†(21) c†(3-1) c(1-1) c(11)⟩ + ⟨c†(1-1) c†(11) c(1-1) c(11)⟩ == 0.0 => 0.46356188862531267
-⟨c†(11) c(31)⟩ + ⟨c†(11) c(21)⟩ == 0.0 => 0.011788246976749156
-⟨c†(51) c(41)⟩ + ⟨c†(71) c(21)⟩ == 0.0 => 0.017595792088201924
⟨c†(11) c†(2-1) c(11) c(2-1)⟩ - ⟨c†(11) c†(2-1) c(1-1) c(21)⟩ - ⟨c†(2-1) c†(31) c(1-1) c(11)⟩ - ⟨c†(1-1) c†(11) c(1-1) c(11)⟩ == 0.0 => 0.3165154116345849
⟨c†(91) c(11)⟩ - ⟨c†(81) c(11)⟩ == 0.0 => 0.0001745531324088747
⟨c†(11) c(11)⟩ + ⟨c†(1-1) c(1-1)⟩ == 1.0 => 4.406275344592814e-11
⟨c†(4-1) c(3-1)⟩ - ⟨c†(5-1) c(2-1)⟩ == 0.0 => 0.006005232153568851
⟨c†(11) c(51)⟩ - ⟨c†(11) c(41)⟩ == 0.0 => 0.00014474347760085396
-⟨c†(31) c(31)⟩ + ⟨c†(21) c(21)⟩ == 0.0 => 0.0002254747299866855
-⟨c†(5-1) c(3-1)⟩ + ⟨c†(4-1) c(2-1)⟩ == 0.0 => 0.01181073509559391
-⟨c†(61) c(31)⟩ + ⟨c†(71) c(21)⟩ == 0.0 => 8.381839568529989e-5
-⟨c†(7-1) c(2-1)⟩ + ⟨c†(9-1) c(1-1)⟩ == 0.0 => 0.01750307775755967
⟨c†(1-1) c†(11) c(2-1) c(21)⟩ - ⟨c†(1-1) c†(11) c(11) c(4-1)⟩ - ⟨c†(11) c†(3-1) c(11) c(2-1)⟩ + ⟨c†(1-1) c†(31) c(11) c(2-1)⟩ == 0.0 => 0.03449533861857952
⟨c†(2-1) c(4-1)⟩ - ⟨c†(4-1) c(2-1)⟩ - ⟨c†(1-1) c(2-1)⟩ + ⟨c†(2-1) c(1-1)⟩ == 0.0 => 4.996003610813204e-16  
-⟨c†(1-1) c†(21) c(1-1) c(31)⟩ + ⟨c†(1-1) c†(31) c(1-1) c(21)⟩ == 0.0 => 7.37257477290143e-18
-⟨c†(3-1) c(5-1)⟩ + ⟨c†(2-1) c(4-1)⟩ == 0.0 => 0.01181073509559355
-⟨c†(31) c(71)⟩ + ⟨c†(21) c(61)⟩ == 0.0 => 0.00027509205068757675
⟨c†(51) c(51)⟩ - ⟨c†(41) c(41)⟩ == 0.0 => 0.0005321627843847265
-⟨c†(1-1) c(4-1)⟩ + ⟨c†(3-1) c(2-1)⟩ == 0.0 => 0.03957621802281004
-⟨c†(31) c(61)⟩ + ⟨c†(51) c(41)⟩ == 0.0 => 0.017511973692516627
-⟨c†(71) c(31)⟩ + ⟨c†(61) c(21)⟩ == 0.0 => 0.00027509205068746573
⟨c†(11) c(31)⟩ + ⟨c†(11) c(21)⟩ - ⟨c†(31) c(11)⟩ - ⟨c†(21) c(11)⟩ == 0.0 => 3.885780586188048e-16
-⟨c†(3-1) c(4-1)⟩ + ⟨c†(5-1) c(2-1)⟩ == 0.0 => 0.006005232153568761
⟨c†(3-1) c(5-1)⟩ - ⟨c†(5-1) c(3-1)⟩ - ⟨c†(1-1) c(3-1)⟩ + ⟨c†(3-1) c(1-1)⟩ == 0.0 => 4.718447854656915e-16  
-⟨c†(11) c†(3-1) c(1-1) c(31)⟩ + ⟨c†(11) c†(2-1) c(1-1) c(21)⟩ == 0.0 => 0.018455024693114913
-⟨c†(11) c(21)⟩ + ⟨c†(31) c(11)⟩ == 0.0 => 0.0117882469767496
⟨c†(3-1) c†(31) c(1-1) c(11)⟩ - 2 ⟨c†(2-1) c†(31) c(1-1) c(11)⟩ + ⟨c†(2-1) c†(21) c(1-1) c(11)⟩ == 0.0 => 0.00399063081320556
⟨c†(41) c(51)⟩ - ⟨c†(51) c(41)⟩ == 0.0 => 2.7755575615628914e-17
⟨c†(21) c(51)⟩ - ⟨c†(41) c(31)⟩ == 0.0 => 0.006005232151201759
-⟨c†(1-1) c(7-1)⟩ + ⟨c†(1-1) c(6-1)⟩ == 0.0 => 0.006027154150668068
-⟨c†(51) c(21)⟩ + ⟨c†(71) c(11)⟩ == 0.0 => 0.006017008505534757
-⟨c†(31) c(11)⟩ + ⟨c†(21) c(11)⟩ == 0.0 => 0.011788246976749683
⟨c†(3-1) c(7-1)⟩ - ⟨c†(2-1) c(6-1)⟩ == 0.0 => 0.0002750920064648922
⟨c†(7-1) c(1-1)⟩ - ⟨c†(6-1) c(1-1)⟩ == 0.0 => 0.006027154150667895
⟨c†(4-1) c(3-1)⟩ - ⟨c†(6-1) c(1-1)⟩ == 0.0 => 0.006015377526877627
⟨c†(1-1) c†(11) c(21) c(3-1)⟩ - ⟨c†(1-1) c†(11) c(2-1) c(31)⟩ + 2 ⟨c†(1-1) c†(11) c(2-1) c(21)⟩ == 0.0 => 0.0067510338628673505
⟨c†(4-1) c(5-1)⟩ - ⟨c†(5-1) c(4-1)⟩ == 0.0 => 1.0408340855860843e-17
⟨c†(11) c(91)⟩ - ⟨c†(11) c(81)⟩ == 0.0 => 0.00017455313240888858
⟨c†(5-1) c(3-1)⟩ - ⟨c†(4-1) c(2-1)⟩ == 0.0 => 0.01181073509559391
-⟨c†(1-1) c†(51) c(1-1) c(11)⟩ + ⟨c†(1-1) c†(41) c(1-1) c(11)⟩ == 0.0 => 0.0015159937473414181
-⟨c†(3-1) c(6-1)⟩ + ⟨c†(5-1) c(4-1)⟩ == 0.0 => 0.01751197361986951
-⟨c†(3-1) c†(31) c(1-1) c(11)⟩ - 2 ⟨c†(21) c†(3-1) c(1-1) c(11)⟩ - ⟨c†(2-1) c†(21) c(1-1) c(11)⟩ == 0.0 => 
0.003990630717709422
⟨c†(31) c(11)⟩ - ⟨c†(21) c(11)⟩ == 0.0 => 0.011788246976749683
-⟨c†(1-1) c†(31) c(1-1) c(31)⟩ + ⟨c†(1-1) c†(21) c(1-1) c(21)⟩ == 0.0 => 0.007986694736105193
-⟨c†(1-1) c(5-1)⟩ + ⟨c†(1-1) c(4-1)⟩ == 0.0 => 0.00014474355567007519
-⟨c†(91) c(11)⟩ + ⟨c†(81) c(11)⟩ == 0.0 => 0.0001745531324088747
-⟨c†(1-1) c†(11) c(2-1) c(31)⟩ - ⟨c†(11) c†(3-1) c(1-1) c(31)⟩ + ⟨c†(1-1) c†(31) c(1-1) c(31)⟩ - ⟨c†(1-1) c†(11) c(1-1) c(11)⟩ == 0.0 => 0.4900036080067848
-⟨c†(21) c(31)⟩ + ⟨c†(31) c(21)⟩ == 0.0 => 2.0816681711721685e-17
-⟨c†(2-1) c(2-1)⟩ + ⟨c†(1-1) c(1-1)⟩ == 0.0 => 0.14704647695481793
⟨c†(1-1) c†(11) c(1-1) c(51)⟩ - ⟨c†(1-1) c†(11) c(1-1) c(41)⟩ == 0.0 => 0.0015159937473414875
⟨c†(2-1) c(5-1)⟩ - ⟨c†(3-1) c(4-1)⟩ == 0.0 => 0.006005232153568775
⟨c†(11) c(31)⟩ - ⟨c†(21) c(11)⟩ == 0.0 => 0.01178824697674924
⟨c†(31) c(31)⟩ - ⟨c†(11) c(11)⟩ == 0.0 => 0.14727195165357948
⟨c†(21) c(31)⟩ - ⟨c†(31) c(21)⟩ == 0.0 => 2.0816681711721685e-17
⟨c†(21) c(31)⟩ - ⟨c†(41) c(11)⟩ == 0.0 => 0.03957621794293671
-⟨c†(1-1) c†(21) c(11) c(3-1)⟩ + ⟨c†(1-1) c†(31) c(11) c(2-1)⟩ == 0.0 => 1.235951271882918e-10
⟨c†(1-1) c(3-1)⟩ - ⟨c†(1-1) c(2-1)⟩ == 0.0 => 0.011788246737419433
⟨c†(1-1) c(3-1)⟩ + ⟨c†(1-1) c(2-1)⟩ - ⟨c†(3-1) c(1-1)⟩ - ⟨c†(2-1) c(1-1)⟩ == 0.0 => 6.938893903907228e-16  
⟨c†(1-1) c(5-1)⟩ - ⟨c†(2-1) c(3-1)⟩ == 0.0 => 0.03943147446714004
⟨c†(1-1) c(5-1)⟩ - ⟨c†(1-1) c(4-1)⟩ == 0.0 => 0.00014474355567007519
-⟨c†(1-1) c(8-1)⟩ + ⟨c†(3-1) c(6-1)⟩ == 0.0 => 0.017593812634403662
-⟨c†(11) c†(3-1) c(1-1) c(11)⟩ + ⟨c†(11) c†(2-1) c(1-1) c(11)⟩ == 0.0 => 0.00587341021734486
⟨c†(3-1) c(5-1)⟩ - ⟨c†(2-1) c(4-1)⟩ == 0.0 => 0.01181073509559355
-⟨c†(2-1) c(6-1)⟩ + ⟨c†(1-1) c(4-1)⟩ == 0.0 => 0.039428409849062346
-⟨c†(3-1) c(7-1)⟩ + ⟨c†(2-1) c(6-1)⟩ == 0.0 => 0.0002750920064648922
⟨c†(1-1) c†(2-1) c(1-1) c(3-1)⟩ - ⟨c†(1-1) c†(3-1) c(1-1) c(2-1)⟩ == 0.0 => 1.3877787807814457e-17
-⟨c†(3-1) c(1-1)⟩ + ⟨c†(2-1) c(1-1)⟩ == 0.0 => 0.0117882467374191
-⟨c†(2-1) c(3-1)⟩ + ⟨c†(3-1) c(2-1)⟩ == 0.0 => 7.28583859910259e-17
-⟨c†(11) c(61)⟩ + ⟨c†(31) c(41)⟩ == 0.0 => 0.006015377691919496
```

观察`2022-5-8-run-2-res.out`会发现，DMRG中只能是零的算符的期望值在bootstrap中确实非常小。（见`2022-5-8-1.xlsx`）

我注意到一个可能有问题的地方。$K = 6$时总共有36个约束。使用
```julia
hubbard_opstr_basis_expected_dmrg_values = map(hubbard_opstr_basis) do op
    benchmark_point_dmrg[op]
end

for constraint_coefficients in H_constraints_coefficients
    println(constraint_coefficients' * hubbard_opstr_basis_expected_dmrg_values)
end
```
做检查，发现
```
0.0     
0.0
0.0
0.0
0.0
0.0
0.0
0.0
0.0
0.0
0.0
-2.7755575615628914e-17
0.0
0.0
0.0
-4.718447854656915e-16
0.0
0.0
3.0531133177191805e-16
0.0
0.0
0.0
-4.996003610813204e-16
0.0
0.0
-3.885780586188048e-16
0.0
0.0
0.0
0.0
6.938893903907228e-16
0.0
0.0
0.0
0.0
-9.71445146547012e-16
```
然而，使用以下代码：
```julia
feasibility_report_sorted = sort(collect(pairs(feasibility_report)), by = x -> x[2], rev = true)

##

for term in feasibility_report_sorted[1:40]
    println(term[1], " => ", term[2])
end
```
会发现一些比较大的值。To list a few:
```
-⟨c†(1-1) c†(11) c(2-1) c(31)⟩ - ⟨c†(11) c†(3-1) c(1-1) c(31)⟩ + ⟨c†(1-1) c†(31) c(1-1) c(31)⟩ - ⟨c†(1-1) c†(11) c(1-1) c(11)⟩ == 0.0 => 0.4900036080067848
⟨c†(1-1) c†(21) c(11) c(2-1)⟩ - ⟨c†(1-1) c†(21) c(1-1) c(21)⟩ - ⟨c†(21) c†(3-1) c(1-1) c(11)⟩ + ⟨c†(1-1) c†(11) c(1-1) c(11)⟩ == 0.0 
=> 0.46356188862531267
-⟨c†(1-1) c†(11) c(21) c(3-1)⟩ - ⟨c†(11) c†(3-1) c(11) c(3-1)⟩ + ⟨c†(1-1) c†(31) c(11) c(3-1)⟩ + ⟨c†(1-1) c†(11) c(1-1) c(11)⟩ == 0.0 => 0.3427316563091772
⟨c†(11) c†(2-1) c(11) c(2-1)⟩ - ⟨c†(11) c†(2-1) c(1-1) c(21)⟩ - ⟨c†(2-1) c†(31) c(1-1) c(11)⟩ - ⟨c†(1-1) c†(11) c(1-1) c(11)⟩ == 0.0 
=> 0.3165154116345849
⟨c†(1-1) c†(11) c(2-1) c(21)⟩ - ⟨c†(1-1) c†(11) c(11) c(4-1)⟩ - ⟨c†(11) c†(3-1) c(11) c(2-1)⟩ + ⟨c†(1-1) c†(31) c(11) c(2-1)⟩ == 0.0 
=> 0.03449533861857952
⟨c†(11) c†(3-1) c(11) c(2-1)⟩ - ⟨c†(11) c†(3-1) c(1-1) c(21)⟩ - ⟨c†(3-1) c†(31) c(1-1) c(11)⟩ + ⟨c†(11) c†(5-1) c(1-1) c(11)⟩ == 0.0 
=> 0.033106185774793344
-⟨c†(4-1) c(4-1)⟩ + ⟨c†(2-1) c(2-1)⟩ == 0.0 => 0.14727503958404914
-⟨c†(41) c(41)⟩ + ⟨c†(21) c(21)⟩ == 0.0 => 0.1472750395404524
⟨c†(3-1) c(3-1)⟩ - ⟨c†(1-1) c(1-1)⟩ == 0.0 => 0.14727195190845083
⟨c†(31) c(31)⟩ - ⟨c†(11) c(11)⟩ == 0.0 => 0.14727195165357948
-⟨c†(2-1) c(2-1)⟩ + ⟨c†(1-1) c(1-1)⟩ == 0.0 => 0.14704647695481793
-⟨c†(21) c(21)⟩ + ⟨c†(11) c(11)⟩ == 0.0 => 0.1470464769235928
⟨c†(5-1) c(5-1)⟩ - ⟨c†(3-1) c(3-1)⟩ == 0.0 => 0.14696835198604402
⟨c†(51) c(51)⟩ - ⟨c†(31) c(31)⟩ == 0.0 => 0.14696835148605436
⟨c†(2-1) c(3-1)⟩ - ⟨c†(4-1) c(1-1)⟩ == 0.0 => 0.039576218022810195
-⟨c†(1-1) c(4-1)⟩ + ⟨c†(3-1) c(2-1)⟩ == 0.0 => 0.03957621802281004
-⟨c†(11) c(41)⟩ + ⟨c†(31) c(21)⟩ == 0.0 => 0.03957621794293681
⟨c†(21) c(31)⟩ - ⟨c†(41) c(11)⟩ == 0.0 => 0.03957621794293671
⟨c†(31) c(71)⟩ - ⟨c†(11) c(51)⟩ == 0.0 => 0.03955875844578475
⟨c†(71) c(31)⟩ - ⟨c†(51) c(11)⟩ == 0.0 => 0.03955875844578462
```
这里面前几个很明显不是从能量约束来的，那它们是哪儿来的呢？

现在的情况就是这样：上面那一大片到处都是violation的输出是拿feasibility report做的，其中的变量是JuMP变量；而直接拿`H_constraints_coefficients`做检查，是看不到violation的。
我们以出现了最大的violation的约束
```
-⟨c†(1-1) c†(11) c(2-1) c(31)⟩ - ⟨c†(11) c†(3-1) c(1-1) c(31)⟩ + ⟨c†(1-1) c†(31) c(1-1) c(31)⟩ - ⟨c†(1-1) c†(11) c(1-1) c(11)⟩ == 0.0 
```
为例。它在`2022-5-8-run-3-res.out`中出现在2212行，由`c†(1-1) c†(11) c(1-1) c(31)`产生，检查其位置，似乎它是由平移对称性产生的。hmm……
第二个violation很大的约束也是来自平移对称性。

那如果我关闭几何对称性呢？

取$K = 6$，会发现
```
Expected ⟨n_i↑ n_i↓⟩:  0.10566243561897877
```
效果竟然比较好……能量是0.732。我们不再改动`2022-5-8-run-3-res.out`，转而在`2022-5-8-run-4-res.out`中运行$K=8$的情况，能量竟然也是0.732……显然我们在这里看到关闭平移对称性，计算似乎已经收敛了。

这是非常奇怪的。考虑到double occupation表现较好，合乎逻辑的做法是调大$U$，观察计算结果。计算结果在`2022-5-8-run-5-res.out`中体现。
结果能量并没有明显变好。这里的逻辑是，虽然$U$增大了以后local repulsion term会变得更加重要，但是double occupation也变得更小了……

总结一下眼下的情况：
- 原有的平移约束和DMRG的结果存在冲突
- 不加平移约束，系统会stuck在一个奇怪的极小值（？）点，但是其上的double occupation是大体正确的

$K = 8$时运行
```julia
M_dmrg = map(M) do var
    jump_benchmark_point[var]
end

eigen(M_dmrg).values
```
得到
```
0.0009925994851962849       
 0.0013351520295694494       
 0.0014340804485045173
 0.0016366203520501025
 0.0016366203582495282
 0.0024933359817290524
 0.002713541460252048
 0.0032418934537399116
 0.0032498238317052726
 0.004369222386015673
 0.004369222409699224
 ⋮
 0.924038695832538
 1.029350273156436
 1.0321964660233158
 1.182952359672838
 1.1853668741311105
 1.3171056549187308
 1.419758734160698
 1.6452507495491049
 1.693912672363227
 3.110133083949282
```

两个最大的infeasibility是
```
⟨c†(11) c†(3-1) c(3-1) c(31)⟩ + ⟨c†(11) c†(3-1) c(2-1) c(31)⟩ + ⟨c†(11) c†(3-1) c(1-1) c(51)⟩ + ⟨c†(3-1) c†(31) c(1-1) c(31)⟩ - ⟨c†(21) c†(3-1) c(1-1) c(31)⟩ - ⟨c†(11) c†(5-1) c(1-1) c(31)⟩ + ⟨c†(1-1) c†(11) c(1-1) c(31)⟩ + ⟨c†(11) c†(3-1) c(1-1) c(11)⟩ == 0.0 => 0.0001848068941629477
-⟨c†(1-1) c†(31) c(3-1) c(31)⟩ + ⟨c†(1-1) c†(31) c(21) c(3-1)⟩ + ⟨c†(1-1) c†(31) c(11) c(5-1)⟩ - ⟨c†(3-1) c†(31) c(11) c(3-1)⟩ - ⟨c†(2-1) c†(31) c(11) c(3-1)⟩ - ⟨c†(1-1) c†(51) c(11) c(3-1)⟩ - ⟨c†(1-1) c†(11) c(11) c(3-1)⟩ - ⟨c†(1-1) c†(31) c(1-1) c(11)⟩ == 0.0 => 0.0001848068941626979
```
另一方面，
```julia
value(cdag(1, 1) * cdag(3, -1) * c(3, -1) * c(3, 1) |> final_expected_real_value) do var
    jump_benchmark_point[var]
end
```
给出0.11，因此这个差别是比较小的。

我们可以合理地得出结论：除了平移和镜像约束以外的代码应该是没问题的。

```
julia> comm(Tx, cdag(1, 1) * c(1, 1) * cdag(1, -1) * c(1, -1)) |> normal_form
c†(1-1) c†(11) c(1-1) c(21) - c†(1-1) c†(11) c(11) c(2-1) - c†(1-1) c†(31) c(1-1) c(11) + c†(11) c†(3-1) c(1-1) c(11)
```
我好像注意到了一个比较麻烦的事情，就是我目前定义的`Tx`真的是正宗的平移算符吗？？

尚没有排除这个问题；在真的排除了这个问题之后，需要分析
```
-⟨c†(4-1) c(4-1)⟩ + ⟨c†(2-1) c(2-1)⟩ == 0.0 => 0.14727503958404914
```
这种问题的来源。

nearest neighbor hopping大体上遵从空间平移对称性；但是，次近邻跃迁，如`dmrg_value(cdag(5, ↓) * c(1, ↓))`和`dmrg_value(cdag(3, ↓) * c(2, ↓))`，符号是相反的。
这可能不是bug而是feature：基态看起来大体上是反铁磁的，因此次近邻格点具有相同的自旋，跃迁应该是不太可能发生的，所以，这两个值符号相反而它们本来应该相等，正好说明了次近邻格点的跃迁基本上是零。
实际上，我们会发现次次近邻跃迁比次近邻还要强，也暗示了这一点。

如果这是事实，那么镜像对称性也是近似成立的。

因此，现在的任务是，编写程序来做格点平移。

无意中发现一个新bug：
```
julia> hubbard_opstr_reflect(hubbard_opstr_basis[end])
c(1-1) c(11) c(3-1) c(31) c(2-1)

julia> ans in hubbard_opstr_basis
false
```
离谱。显然前面DFS的代码又写错了。

目前的bond是
```
Expected ⟨n_i↑ n_i↓⟩:  0.09326223878165446

Expected ⟨Sz_i⟩:  -1.6580478934269394e-8
```

保存至`2022-5-8-run-6-res.out`

# 2022.5.9

`2022-5-9-run-1-res.out`是$U=4, K = 10$的输出，slurm id为1571393；输出的能量为-0.62，double occupation正确。
与正确值相差约0.5，对应韩希之图1的1000个算符的情况。奇怪……但是我用了100000个算符了。

保持$K = 10$，运行：
- $U = 6$: slurm id 1588792 输出文件`2022-5-9-run-2-res.out`
- $U = 8$: slurm id 1588806 输出文件`2022-5-9-run-3-res.out`
- $U = 10$: slurm id 1588872 输出文件 `2022-5-9-run-4-res.out`

然后尝试运行一个较大规模的问题：
- slurm id 1588986，输出文件 `2022-5-9-run-5-res.out`，$K = 12, U = 4$
- slurm id 1594191，输出文件 `2022-5-9-run-6-res.out`，$K = 12, U = 6$
- slurm id 1954243，输出文件 `2022-5-9-run-7-res.out`，$K = 12, U = 8$
- slurm id 1594281，输出文件 `2022-5-9-run-8-res.out`，$K = 12, U = 10$